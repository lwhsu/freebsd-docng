<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r54321
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="geom">

  <info>
    <title>GEOM: Modulares Framework zur
      Plattentransformation</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Daniel</firstname>
	  <surname>Seuffert</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	</personname>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="geom-synopsis">
    <title>Übersicht</title>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary><acronym>GEOM</acronym> Disk Framework</primary>
      <see><acronym>GEOM</acronym></see>
    </indexterm>

    <para><acronym>GEOM</acronym> erlaubt den Zugriff und die
      Kontrolle von Klassen, wie beispielsweise Master Boot Records
      und <acronym>BSD</acronym>-Label, durch die Nutzung von
      Datenträgern (Providern) oder den besonderen Dateien in
      <filename>/dev</filename>.  Verschiedene Software
      <acronym>RAID</acronym>-Konfigurationen unterstützend, gewährt
      <acronym>GEOM</acronym> transparenten Zugriff auf das
      Betriebssystem und die System-Dienstprogramme.</para>

    <para>Dieses Kapitel behandelt den Einsatz von Laufwerken mit
      dem <acronym>GEOM</acronym>-Framework in &os;.  Dies beinhaltet
      auch die wichtigen
      <acronym>RAID</acronym>-Überwachungswerkzeuge, welche das
      Framework zur Konfiguration nutzen.  Dieses Kapitel ist kein
      ausführlicher Leitfaden für
      <acronym>RAID</acronym>-Konfigurationen.  Nur die von
      <acronym>GEOM</acronym> unterstützten
      <acronym>RAID</acronym>-Klassen werden erörtert.</para>

    <para>Nach Lesen dieses Kapitels werden Sie folgendes
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Welche Art von
	  <acronym>RAID</acronym>-Unterstützung durch
	  <acronym>GEOM</acronym> verfügbar ist.</para>
      </listitem>

      <listitem>
	<para>Wie man die Basis-Dienstprogramme nutzt, um
	  verschiedene <acronym>RAID</acronym>-Stufen zu
	  konfigurieren, zu manipulieren und zu warten.</para>
      </listitem>

      <listitem>
	<para>Wie man mittels <acronym>GEOM</acronym> spiegelt,
	  striped, verschlüsselt und entfernte Laufwerke
	  verbindet.</para>
      </listitem>

      <listitem>
	<para>Wie man an Laufwerken, welche an das
	  <acronym>GEOM</acronym>-Framework angeschlossen sind, Fehler
	  behebt.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Verstehen, wie &os; Laufwerke behandelt
	  (<xref linkend="disks"/>).</para>
      </listitem>

      <listitem>
	<para>Wissen wie man einen neuen &os;-Kernel konfiguriert
	  und installiert (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="geom-striping">
    <info>
      <title>RAID0 - Striping</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Murray</firstname>
	    <surname>Stokely</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Striping</primary>
    </indexterm>

    <para>Striping (stripe = Streifen) fasst verschiedene Laufwerke in
      einem einzigen Datenträger zusammen.  Dies wird durch die
      Nutzung von Hardware-Controllern bewerkstelligt.  Das
      <acronym>GEOM</acronym>-Subsystem unterstützt
      Software-<acronym>RAID0</acronym>, welches auch als Striping
      bekannt ist.  Bei dieser Technik wird kein
      <acronym>RAID</acronym>-Controller benötigt.</para>

    <para>In einem <acronym>RAID</acronym>0-System werden die Daten
      in einzelne Blöcke aufgeteilt, welche über alle
      angeschlossenen Laufwerke in einem Datenfeld (Array) geschrieben
      werden.  Anstatt darauf warten zu müssen, dass 256K auf
      ein einzelnes Laufwerk geschrieben werden, kann ein
      <acronym>RAID0</acronym>-System gleichzeitig 64K auf jedes von
      vier Laufwerken schreiben mit entsprechend besserer
      <acronym>I/O</acronym>-Leistung.  Dieser Durchsatz kann durch
      die Verwendung mehrerer Controller noch zusätzlich gesteigert
      werden.</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="geom/striping" align="center"/>
      </imageobject>

      <textobject>
	<phrase>Disk Striping Illustration</phrase>
      </textobject>
    </mediaobject>

    <para>Jedes Laufwerk in einem <acronym>RAID</acronym>0-Stripe
      muss die gleiche Größe haben, da
      <acronym>I/O</acronym>-Anforderungen für das Lesen und Schreiben
      abwechselnd auf mehrere Laufwerke parallel erfolgen.</para>

    <note>
      <para><acronym>RAID0</acronym> bietet keine Redundanz.  Das
	bedeutet, dass wenn eine Platte im Array ausfällt, die
	gesamten Daten auf den Platten verloren gehen.  Wenn es sich
	um wichtige Daten handelt, sollten Sie eine Backup-Strategie
	entwickeln, die regelmäßig Sicherungen auf einem entferntem
	System speichert.</para>
    </note>

    <para>Die Erstellung eines <acronym>GEOM</acronym>-basierten
      <acronym>RAID0</acronym> auf einem &os;-System wird im folgenden
      beschrieben.  Nachdem das Stripe erzeugt wurde, finden Sie in
      &man.gstripe.8; weitere Informationen zur Verwaltung der
      vorhandenen Stripes.</para>

    <procedure>
      <title>Ein Stripe aus unformatierten
	<acronym>ATA</acronym>-Platten erzeugen</title>

      <step>
	<para>Laden Sie das
	  <filename>geom_stripe.ko</filename>-Modul:</para>

	<screen>&prompt.root; <userinput>kldload geom_stripe</userinput></screen>
      </step>

      <step>
	<para>Stellen Sie sicher, dass ein geeigneter Mountpunkt
	  existiert.  Falls dieser Datenträger eine Root-Partition
	  werden soll, dann nutzen Sie zeitweise einen anderen
	  Mountpunkt, beispielsweise
	  <filename>/mnt</filename>.</para>
      </step>

      <step>
	<para>Bestimmen Sie die Gerätenamen derjenigen Platten,
	  welche gestriped werden sollen, und erzeugen Sie ein neues
	  Stripe-Gerät.  Das folgende Beispiel verwendet zwei
	  unbenutzte und unpartitionierte
	  <acronym>ATA</acronym>-Platten, die gestriped werden sollen.
	  Die Gerätenamen lauten <filename>/dev/ad2</filename> und
	  <filename>/dev/ad3</filename>:</para>

	<screen>&prompt.root; <userinput>gstripe label -v st0 /dev/ad2 /dev/ad3</userinput>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</screen>
      </step>

      <step>
	<para>Schreiben Sie einen Standard-Label (auch als
	  Partitions-Tabelle bekannt) auf den neuen Datenträger
	  und installieren Sie den normalen Bootstrap-Code:</para>

	<screen>&prompt.root; <userinput>bsdlabel -wB /dev/stripe/st0</userinput></screen>
      </step>

      <step>
	<para>Dieser Prozess sollte zwei weitere Geräte im
	  Verzeichnis <filename>/dev/stripe</filename> (zusätzlich zum
	  Gerät <filename>st0</filename>) erzeugt haben.  Diese
	  schliessen <filename>st0a</filename> und
	  <filename>st0c</filename> ein.  Nun kann mit
	  <command>newfs</command> ein
	  <acronym>UFS</acronym>-Dateisystem auf dem Gerät
	  <filename>st0a</filename> erzeugt werden:</para>

	<screen>&prompt.root; <userinput>newfs -U /dev/stripe/st0a</userinput></screen>

	<para>Viele Zahlen rauschen nun über den Bildschirm
	  und nach ein paar Sekunden wird der Prozess abgeschlossen
	  sein.  Der Datenträger wurde erzeugt und kann in den
	  Verzeichnisbaum eingehängt werden.</para>
      </step>

      <step>
	<para>Um das erzeugte Stripe manuell zu mounten:</para>

	<screen>&prompt.root; <userinput>mount /dev/stripe/st0a /mnt</userinput></screen>
      </step>

      <step>
	<para>Um das erzeugte Dateisystem automatisch während des
	  Startvorgangs zu mounten, muss die Datenträgerinformation
	  in <filename>/etc/fstab</filename> eingetragen werden.  In
	  diesem Beispiel wird ein permanenter Mountpunkt namens
	  <filename>stripe</filename> erstellt:</para>

	<screen>&prompt.root; <userinput>mkdir /stripe</userinput>
&prompt.root; <userinput>echo "/dev/stripe/st0a /stripe ufs rw 2 2" \</userinput>
<userinput>&gt;&gt; /etc/fstab</userinput></screen>
      </step>

      <step>
	<para>Das <filename>geom_stripe.ko</filename>-Modul muss
	  ebenfalls automatisch beim Systemstart geladen werden (durch
	  die Aufnahme der folgenden Zeile in die Datei
	  <filename>/boot/loader.conf</filename>):</para>

	<screen>&prompt.root; <userinput>echo 'geom_stripe_load="YES"' &gt;&gt; /boot/loader.conf</userinput></screen>
      </step>
    </procedure>
  </sect1>

  <sect1 xml:id="geom-mirror">
    <title>RAID1 - Spiegelung</title>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Disk Mirroring</primary>
    </indexterm>
    <indexterm>
      <primary>RAID1</primary>
    </indexterm>

    <para>Spiegelung (<acronym>RAID1</acronym> /
      <emphasis>Mirroring</emphasis>) ist eine
      Technik, bei der identische Daten auf mehr als ein Laufwerk
      geschrieben werden.  Spiegel werden in der Regel zum Schutz vor
      Datenverlust aufgrund von Festplattenausfällen verwendet.  Jedes
      Laufwerk in einem Spiegel enthält eine identische Kopie der
      Daten.  Wenn ein einzelnes Laufwerk ausfällt, funktioniert der
      Spiegel weiterhin und die Daten werden von den restlichen
      Festplatten bereit gestellt.  Der Rechner läuft einfach weiter
      und der Administrator hat die Gelegentheit, das defekte Laufwerk
      auszutauschen.</para>

    <para>Zwei häufige Situationen werden in diesem Beispiel
      erläutert.  Im ersten Beispiel wird ein Spiegel aus zwei
      neuen Laufwerken erstellt, der die existierende Platte ersetzt.
      Das zweite Beispiel erzeugt ein Spiegel mit einem einzigen
      Laufwerk, kopiert dann die Daten von der alten Platte und fügt
      die alte Platte zum Spiegel hinzu.  Obwohl dieses Verfahren
      etwas komplizierter ist, wird nur ein neues Laufwerk
      benötigt.</para>

    <para>Traditionell sind die Laufwerke in einem Spiegel vom
      gleichen Modell und besitzen die gleiche Kapazität.  Dies ist
      jedoch keine Voraussetzung für &man.gmirror.8;.  Hier können
      Spiegel mit unterschiedlichen Kapazitäten verwendet werden.  Die
      Kapazität richtet sich dann nach dem kleinsten Laufwerk im
      Spiegel.  Zusätzlicher Speicherplatz auf größeren Laufwerken
      bleibt dann ungenutzt.  Werden später weitere Laufwerke zum
      Spiegel hinzugefügt, müssen diese mindestens so viel Kapazität
      haben wie das kleinste Laufwerk im Spiegel.</para>

    <warning>
      <para>Die hier gezeigten Verfahren löschen keine Daten.  Dennoch
	sollte, wie bei jeder größeren Operation, zuerst eine
	vollständige Sicherung erstellt werden.</para>
    </warning>

    <warning>
      <para>Obwohl in diesem Abschnitt &man.dump.8; zum Kopieren der
	Dateisysteme verwendet wird, funktioniert es nicht auf
	Dateisystemen mit aktiviertem Soft-Updates Journaling.  In
	&man.tunefs.8; finden Sie Informationen, wie Sie Soft-Updates
	Journaling erkennen und deaktivieren.</para>
    </warning>

    <sect2 xml:id="geom-mirror-metadata">
      <title>Probleme mit Metadaten</title>

      <para>Viele Plattensysteme speichern Metadaten am Ende der
	Platte.  Alte Metadaten sollten vor der Wiederverwendung in
	einem Spiegel gelöscht werden, da die meisten Probleme aus
	zwei Arten von übrig gebliebenen Metadaten resultieren:
	<acronym>GPT</acronym>-Partitionstabellen und alte Metadaten
	aus einem vorherigen Spiegel.</para>

      <para><acronym>GPT</acronym>-Metadaten können mit &man.gpart.8;
	gelöscht werden.  Dieses Beispiel löscht sowohl die primären,
	als auch die <acronym>GPT</acronym>-Partitionstabelle von der
	Festplatte <filename>ada8</filename>:</para>

      <screen>&prompt.root; <userinput>gpart destroy -F ada8</userinput></screen>

      <para>Mit &man.gmirror.8; kann eine Platte aus einem aktiven
	Spiegel entfernt und gleichzeitig die Metadaten gelöscht
	werden.  In diesem Beispiel wird die Platte
	<filename>ada8</filename> aus dem aktiven Spiegel
	<filename>gm4</filename> entfernt:</para>

      <screen>&prompt.root; <userinput>gmirror remove gm4 ada8</userinput></screen>

      <para>Wenn der Spiegel nicht aktiv ist, sich jedoch noch alte
	Metadaten auf der Festplatte befinden, benutzen Sie
	<command>gmirror clear</command>, um die Metadaten zu
	entfernen:</para>

      <screen>&prompt.root; <userinput>gmirror clear ada8</userinput></screen>

      <para>&man.gmirror.8; speichert einen Datenblock an Metadaten am
	Ende der Festplatte.  Da das
	<acronym>GPT</acronym>-Partitionschema die Metadaten auch am
	Ende der Platte speichert, wird es nicht empfohlen, mit
	&man.gmirror.8; einen Spiegel aus einem gesamten
	<acronym>GPT</acronym>-Datenträger zu erstellen.  In diesen
	Fällen sollte eine <acronym>MBR</acronym>-Partitionierung
	benutzt werden, weil hier nur eine Partitionstabelle am Anfang
	der Platte gespeichert wird und somit nicht mit den Metadaten
	des Spiegels im Konflikt steht.</para>
    </sect2>

    <sect2 xml:id="geom-mirror-two-new-disks">
      <title>Einen Spiegel mit zwei neuen Festplatten
	erstellen</title>

      <para>In diesem Beispiel wurde &os; bereits auf der vorhandenen
	Festplatte <filename>ada0</filename> installiert.  Zwei neue
	Platten, <filename>ada1</filename> und
	<filename>ada2</filename>, wurden bereits mit dem System
	verbunden.  Ein neuer Spiegel soll mit diesen beiden Platten
	erzeugt und verwendet werden, um die alte vorhandene Platte zu
	ersetzen.</para>

      <para>Das Kernelmodul <filename>geom_mirror.ko</filename> muss
	entweder in den Kernel eingebaut, oder zur Laufzeit geladen
	werden.  Sie können das Modul manuell laden:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

      <para>Erstellen Sie den Spiegel mit den beiden neuen
	Festplatten:</para>

      <screen>&prompt.root; <userinput>gmirror label -v gm0 /dev/ada1 /dev/ada2</userinput></screen>

      <para><filename>gm0</filename> ist ein vom Benutzer gewählter
	Name, der dem neuen Spiegel zugeordnet wird.  Nachdem der
	Spiegel gestartet wurde, erscheint dieser Gerätename in
	<filename>/dev/mirror/</filename>.</para>

      <para><acronym>MBR</acronym>- und
	<application>bsdlabel</application>-Partitionstabellen können
	jetzt auf dem neuen Spiegel erzeugt werden.  Dieses Beispiel
	verwendet das herkömmliche Dateisystem-Layout für
	<filename>/</filename>, swap, <filename>/var</filename>,
	<filename>/tmp</filename> und <filename>/usr</filename>.  Eine
	einzelne Root- und Swap-Partition würde ebenfalls
	funktionieren.</para>

      <para>Die Partitionen auf dem Spiegel müssen nicht zwingend die
	gleiche Größe wie die auf der Festplatte haben, aber sie
	müssen groß genug sein, um alle Daten aufnehmen zu können, die
	bereits auf <filename>ada0</filename> gespeichert sind.</para>

      <screen>&prompt.root; <userinput>gpart create -s MBR mirror/gm0</userinput>
&prompt.root; <userinput>gpart add -t freebsd -a 4k mirror/gm0</userinput>
&prompt.root; <userinput>gpart show mirror/gm0</userinput>
=&gt;       63  156301423  mirror/gm0  MBR  (74G)
         63         63                    - free -  (31k)
        126  156301299                 1  freebsd  (74G)
  156301425         61                    - free -  (30k)</screen>

      <screen>&prompt.root; <userinput>gpart create -s BSD mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart show mirror/gm0s1</userinput>
=&gt;        0  156301299  mirror/gm0s1  BSD  (74G)
          0          2                      - free -  (1.0k)
          2    4194304                   1  freebsd-ufs  (2.0G)
    4194306    8388608                   2  freebsd-swap (4.0G)
   12582914    4194304                   4  freebsd-ufs  (2.0G)
   16777218    2097152                   5  freebsd-ufs  (1.0G)
   18874370  137426928                   6  freebsd-ufs  (65G)
  156301298          1                      - free -  (512B)</screen>

      <para>Damit von dem Spiegel gebootet werden kann, muss der
	Bootcode in den <acronym>MBR</acronym> installiert, ein
	bsdlabel erstellt und die aktive Partition gesetzt
	werden:</para>

      <screen>&prompt.root; <userinput>gpart bootcode -b /boot/mbr mirror/gm0</userinput>
&prompt.root; <userinput>gpart set -a active -i 1 mirror/gm0</userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/boot mirror/gm0s1</userinput></screen>

      <para>Erstellen Sie die Dateisysteme auf dem neuen Spiegel und
	aktivieren Sie Soft-Updates:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1d</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1e</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1f</userinput></screen>

      <para>Die Dateisysteme der vorhandenen Platte
	<filename>ada0</filename> können jetzt mit &man.dump.8; und
	&man.restore.8; auf den Spiegel kopiert werden.</para>

      <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1d /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1e /mnt/tmp</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1f /mnt/usr</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</userinput></screen>

      <para>Fügen Sie die Dateisysteme für den Spiegel in
	<filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting># Device          Mountpoint       FStype  Options Dump    Pass#
/dev/mirror/gm0s1a      /               ufs     rw       1       1
/dev/mirror/gm0s1b      none            swap    sw       0       0
/dev/mirror/gm0s1d      /var            ufs     rw       2       2
/dev/mirror/gm0s1e      /tmp            ufs     rw       2       2
/dev/mirror/gm0s1f      /usr            ufs     rw       2       2</programlisting>

      <para>Wenn das Modul <filename>geom_mirror.ko</filename> nicht
	im Kernel enthalten ist, können Sie
	<filename>/mnt/boot/loader.conf</filename> bearbeiten, damit
	das Modul beim Systemstart geladen wird:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Starten Sie das System neu und überprüfen Sie, ob
	alle Daten erfolgreich kopiert wurden.  Das
	<acronym>BIOS</acronym> wird den Spiegel vermutlich als
	zwei einzelne Laufwerke erkennen.  Da beide Laufwerke
	jedoch identisch sind, spielt es keine Rolle, welches
	Laufwerk zum Booten ausgewählt wird.</para>

      <para>Falls es Probleme beim Booten gibt, lesen Sie den
	<xref linkend="gmirror-troubleshooting"/>.  Die alte
	Festplatte <filename>ada0</filename> kann vom System
	getrennt und als Offline-Sicherung aufbewahrt werden.</para>

      <para>Im laufenden Betrieb verhält sich der Spiegel genau
	wie ein einzelnes Laufwerk.</para>
    </sect2>

    <sect2 xml:id="geom-mirror-existing-drive">
      <title>Einen Spiegel mit einem vorhandenen Laufwerk
	erstellen</title>

      <para>In diesem Beispiel wurde &os; bereits auf der
	Festplatte <filename>ada0</filename> installiert und eine
	weitere Platte, <filename>ada1</filename>, wurde an
	das System angeschlossen.  Zunächst wird ein Spiegel mit
	einer Festplatte erstellt, dann das vorhandene System auf
	den Spiegel kopiert.  Zuletzt wird die alte Festplatte in den
	Spiegel eingefügt.  Diese etwas komplexere Vorgehensweise ist
	erforderlich, da <command>gmirror</command> 512 Byte an
	Metadaten am Ende der Festplatte speichert, und die bestehende
	Platte, <filename>ada0</filename>, in der Regel den Platz
	bereits belegt hat.</para>

      <para>Laden Sie das Kernelmodul
	<filename>geom_mirror.ko</filename>:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

      <para>Prüfen Sie mit <command>diskinfo</command> die Mediengröße
	der vorhandenen Festplatte:</para>

      <screen>&prompt.root; <userinput>diskinfo -v ada0 | head -n3</userinput>
/dev/ada0
        512             # sectorsize
        1000204821504   # mediasize in bytes (931G)</screen>

      <para>Jetzt können Sie den Spiegel auf der neuen Festplatte
	erzeugen.  Um sicherzustellen, dass die Kapazität nicht größer
	ist, als die Kapazität der vorhandenen Platte
	<filename>ada0</filename>, benutzen Sie &man.gnop.8; um eine
	Platte mit der exakt gleichen Größe zu imitieren.  Diese
	Platte speichert keine Daten und wird nur verwendet, um die
	Größe des Spiegels zu begrenzen.  &man.gmirror.8; wird die
	Kapazität des Spiegels auf die Größe von
	<filename>gzero.nop</filename> beschränken, auch wenn die neue
	Festplatte <filename>ada1</filename> mehr Platz zur Verfügung
	hätte.  Beachten Sie, dass
	<replaceable>1000204821504</replaceable> in der zweiten Zeile
	der ermittelten Mediengröße von <command>diskinfo</command>
	entspricht.</para>

      <screen>&prompt.root; <userinput>geom zero load</userinput>
&prompt.root; <userinput>gnop create -s 1000204821504 gzero</userinput>
&prompt.root; <userinput>gmirror label -v gm0 gzero.nop ada1</userinput>
&prompt.root; <userinput>gmirror forget gm0</userinput></screen>

      <para>Da <filename>gzero.nop</filename> keine Daten speichert,
	sieht der Spiegel sie als nicht verbunden an.  Der Spiegel ist
	so konfiguriert, dass er nicht verbundene Komponenten einfach
	<quote>vergisst</quote>.  Das Ergebnis ist ein Spiegel mit nur
	einer einzigen Platte, <filename>ada1</filename>.</para>

      <para>Sehen Sie sich nach der Erstellung von
	<filename>gm0</filename> die Partitionstabelle von
	<filename>ada0</filename> an.  Diese Ausgabe stammt von einer
	1&nbsp;TB Festplatte.  Falls am Ende der Platte noch freier
	Speicherplatz ist, kann der Inhalt von
	<filename>ada0</filename> direkt auf den Spiegel kopiert
	werden.</para>

      <para>Falls jedoch der gesamte Speicherplatz auf der Platte
	zugeordnet ist, dann gibt es keinen Platz mehr für die 512
	Byte Metadaten für den Spiegel am Ende der Platte, wie in
	dieser Auflistung zu sehen.</para>

      <screen>&prompt.root; <userinput>gpart show ada0</userinput>
=&gt;        63  1953525105        ada0  MBR  (931G)
          63  1953525105           1  freebsd  [active]  (931G)</screen>

      <para>In diesem Fall muss die Partitionstabelle bearbeitet
	werden, um die Kapazität von <filename>mirror/gm0</filename>
	um einen Sektor zu reduzieren.  Dieses Verfahren wird später
	erläutert.</para>

      <para>In beiden Fällen sollte die Partitionstabelle der primären
	Platte mit <command>gpart backup</command> gesichert
	werden.</para>

      <screen>&prompt.root; <userinput>gpart backup ada0 &gt; table.ada0</userinput>
&prompt.root; <userinput>gpart backup ada0s1 &gt; table.ada0s1</userinput></screen>

      <para>Diese Kommandos erstellen zwei Dateien,
	<filename>table.ada0</filename> und
	<filename>table.ada0s1</filename>.  Das Beispiel verwendet
	eine 1&nbsp;TB Festplatte:</para>

      <screen>&prompt.root; <userinput>cat table.ada0</userinput>
MBR 4
1 freebsd         63 1953525105   [active]</screen>

      <screen>&prompt.root; <userinput>cat table.ada0s1</userinput>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</screen>

      <para>Wenn am Ende der Platte kein Platz vorhanden ist, muss
	die Größe des Slice und der letzten Partition verringert
	werden.  Bearbeiten Sie die beiden Dateien, und verringern
	Sie die Größe der Slice und der Partition jeweils um eins.
	Dies bezieht sich auf die letzten Zahlen in der Liste.</para>

      <screen>&prompt.root; <userinput>cat table.ada0</userinput>
MBR 4
1 freebsd         63 <emphasis>1953525104</emphasis>   [active]</screen>

      <screen>&prompt.root; <userinput>cat table.ada0s1</userinput>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  <emphasis>984640880</emphasis></screen>

      <para>Wenn mindestens ein Sektor der Platte nicht zugewiesen
	wurde, kann die Platte ohne Modifikation verwendet
	werden.</para>

      <para>Jetzt kann die Partitionstabelle auf
	<filename>mirror/gm0</filename> wiederhergestellt
	werden:</para>

      <screen>&prompt.root; <userinput>gpart restore mirror/gm0 &lt; table.ada0</userinput>
&prompt.root; <userinput>gpart restore mirror/gm0s1 &lt; table.ada0s1</userinput></screen>

      <para>Prüfen Sie die Partitionstabellen mit
	<command>gpart show</command>.  Dieses Beispiel nutzt
	<filename>gm0s1a</filename> für <filename>/</filename>,
	<filename>gm0s1d</filename> für <filename>/var</filename>,
	<filename>gm0s1e</filename> für <filename>/usr</filename>,
	<filename>gm0s1f</filename> für <filename>/data1</filename>
	und <filename>gm0s1g</filename> für
	<filename>/data2</filename>.</para>

      <screen>&prompt.root; <userinput>gpart show mirror/gm0</userinput>
=&gt;        63  1953525104  mirror/gm0  MBR  (931G)
          63  1953525042           1  freebsd  [active]  (931G)
  1953525105          62              - free -  (31k)

&prompt.root; <userinput>gpart show mirror/gm0s1</userinput>
=&gt;         0  1953525042  mirror/gm0s1  BSD  (931G)
           0     2097152             1  freebsd-ufs  (1.0G)
     2097152    16777216             2  freebsd-swap  (8.0G)
    18874368    41943040             4  freebsd-ufs  (20G)
    60817408    20971520             5  freebsd-ufs  (10G)
    81788928   629145600             6  freebsd-ufs  (300G)
   710934528  1242590514             7  freebsd-ufs  (592G)
  1953525042          63                - free -  (31k)</screen>

      <para>Sowohl die Slice, als auch die letzte Partition, muss
	mindestens einen freien Block am Ende der Platte haben.</para>

      <para>Erstellen Sie Dateisysteme auf diesen neuen
	Partitionen:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1d</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1e</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1f</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1g</userinput></screen>

      <para>Damit Sie von dem Spiegel booten können, müssen Sie den
	Bootcode in den <acronym>MBR</acronym> installieren, ein
	bsdlabel anlegen und das aktive Slice setzen:</para>

      <screen>&prompt.root; <userinput>gpart bootcode -b /boot/mbr mirror/gm0</userinput>
&prompt.root; <userinput>gpart set -a active -i 1 mirror/gm0</userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/boot mirror/gm0s1</userinput></screen>

      <para>Bearbeiten Sie <filename>/etc/fstab</filename>, um die
	neuen Partitionen auf dem Spiegel nutzen zu können.  Speichern
	Sie zunächst eine Kopie der Datei unter
	<filename>/etc/fstab.orig</filename>:</para>

      <screen>&prompt.root; <userinput>cp /etc/fstab /etc/fstab.orig</userinput></screen>

      <para>Ersetzen Sie in <filename>/etc/fstab</filename>
	<filename>/dev/ada0</filename> durch
	<filename>mirror/gm0</filename>.</para>

      <programlisting># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</programlisting>

      <para>Wenn das Modul <filename>geom_mirror.ko</filename> nicht
	im Kernel enthalten ist, können Sie
	<filename>/boot/loader.conf</filename> bearbeiten, damit
	das Modul beim Systemstart geladen wird:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Die Dateisysteme der ursprünglichen Platte können jetzt
	mit &man.dump.8; und &man.restore.8; auf den Spiegel kopiert
	werden.  Wenn Sie das Dateisystem mit
	<command>dump -L</command> sichern, wird zunächst ein Snapshot
	des Dateisystems erstellt, was einige Zeit dauern kann.</para>

      <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1d /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1e /mnt/usr</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1f /mnt/data1</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1g /mnt/data2</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</userinput></screen>

      <para>Starten Sie das System neu und booten Sie von
	<filename>ada1</filename>.  Wenn alles funktioniert, wird
	das System von <filename>mirror/gm0</filename> booten,
	welches jetzt die gleichen Daten enthält wie
	<filename>ada0</filename>.  Lesen Sie <xref
	  linkend="gmirror-troubleshooting"/>, falls es Probleme beim
	Booten gibt.</para>

      <para>An dieser Stelle besteht der Spiegel immer noch aus der
	einzelnen Platte <filename>ada1</filename>.</para>

      <para>Nachdem erfolgreich von <filename>mirror/gm0</filename>
	gebootet wurde, besteht der letzte Schritt darin,
	<filename>ada0</filename> in den Spiegel einzufügen.</para>

      <important>
	<para>Wenn Sie <filename>ada0</filename> in den Spiegel
	  einfügen, wird der Inhalt der Platte mit den Daten aus
	  dem Spiegel überschrieben.  Sie müssen sicherstellen, das
	  <filename>mirror/gm0</filename> den gleichen Inhalt wie
	  <filename>ada0</filename> hat, bevor Sie
	  <filename>ada0</filename> zum Spiegel hinzufügen.  Falls der
	  zuvor mit &man.dump.8; und &man.restore.8; kopierte Inhalt
	  nicht mit dem von <filename>ada0</filename> identisch ist,
	  machen Sie die Änderungen an <filename>/etc/fstab</filename>
	  rückgängig, starten Sie das System neu und beginnen Sie die
	  Prozedur von vorn.</para>
      </important>

      <screen>&prompt.root; <userinput>gmirror insert gm0 ada0</userinput>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</screen>

      <para>Die Synchronisation zwischen den beiden Platten wird
	direkt gestartet.  Verwenden Sie <command>gmirror
	  status</command> um den Fortschritt zu beobachten.</para>

      <screen>&prompt.root; <userinput>gmirror status</userinput>
      Name    Status  Components
girror/gm0  DEGRADED  ada1 (ACTIVE)
                      ada0 (SYNCHRONIZING, 64%)</screen>

      <para>Nach einer Weile wird die Wiederherstellung abgeschlossen
	sein.</para>

      <screen>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
&prompt.root; <userinput>gmirror status</userinput>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 (ACTIVE)
                      ada0 (ACTIVE)</screen>

      <para><filename>mirror/gm0</filename> besteht nun aus den beiden
	Platten <filename>ada0</filename> und
	<filename>ada1</filename>.  Der Inhalt der beiden Platten wird
	automatisch miteinander synchronisiert.  Im laufenden Betrieb
	verhält sich <filename>mirror/gm0</filename> wie eine einzelne
	Festplatte.</para>
    </sect2>

    <sect2 xml:id="gmirror-troubleshooting">
      <title>Fehlerbehebung</title>

      <para>Falls das System nicht mehr startet, müssen
	möglicherweise die <acronym>BIOS</acronym>-Einstellungen
	geändert werden, um von dem neuen gespiegelten Laufwerk zu
	booten.  Beide Platten des Spiegels können zum Booten
	verwendet werden, da sie als Komponenten des Spiegels
	identische Daten enthalten.</para>

      <para>Wenn der Bootvorgang mit der folgenden Meldung abbricht,
	ist irgendwas mit dem Spiegel nicht in Ordnung:</para>

      <screen>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options=rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; [options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified (optional) option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)

  ?               List valid disk boot devices
  .               Yield 1 second (for background tasks)
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</screen>

      <para>Dieses Problem kann durch ein nicht geladenes
	Kernelmodul <filename>geom_mirror.ko</filename> in
	<filename>/boot/loader.conf</filename> verursacht werden.
	Um das Problem zu beheben, booten Sie von einem
	&os;-Installationsmedium und wählen Sie
	<literal>Shell</literal> an der Eingabeaufforderung.  Laden
	Sie dann das Modul und hängen Sie den Spiegel ein:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput></screen>

      <para>Bearbeiten Sie dann
	<filename>/mnt/boot/loader.conf</filename> und fügen Sie
	eine Zeile für das Kernelmodul hinzu:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Speichern Sie die Datei und starten Sie das System
	neu.</para>

      <para>Andere Probleme, die <errorname>error 19</errorname>
	verursachen können, sind nur mit mehr Aufwand zu beheben.
	Obwohl das System von <filename>ada0</filename> booten
	sollte, wird ein weiterer Prompt erscheinen, wenn
	<filename>/etc/fstab</filename> fehlerhaft ist.  Geben
	Sie am Loader-Prompt <literal>ufs:/dev/ada0s1a</literal> ein
	und drücken Sie <keycap>Enter</keycap>.  Machen Sie die
	Änderungen an <filename>/etc/fstab</filename> rückgängig und
	hängen Sie anstelle des Spiegels die originale Festplatte
	(<filename>ada0</filename>) ein.  Starten Sie dann das
	System neu und versuchen Sie den Vorgang erneut.</para>

      <screen>Enter full pathname of shell or RETURN for /bin/sh:
&prompt.root; <userinput>cp /etc/fstab.orig /etc/fstab</userinput>
&prompt.root; <userinput>reboot</userinput></screen>
    </sect2>

    <sect2>
      <title>Wiederherstellung des Systems nach einem
	Plattenausfall</title>

      <para>Der Vorteil der Plattenspiegelung ist, dass eine Platte
	ausfallen kann, ohne dass Sie dabei Daten verlieren.  Falls
	<filename>ada0</filename> aus dem obigen Beispiel ausfällt,
	steht der Spiegel weiterhin zur Verfügung und bietet die Daten
	von der verbleibenden Platte <filename>ada1</filename>
	an.</para>

      <para>Um das ausgefallene Laufwerk zu ersetzen, muss das System
	heruntergefahren werden und das ausgefallene Laufwerk durch
	ein neues Laufwerk von gleicher oder größerer Kapazität
	ersetzt werden.  Hersteller verwenden oft etwas
	willkürliche Werte für die Kapazität.  Der einzige Weg, um
	wirklich sicher zu sein, ist die Gesamtzahl der Sektoren von
	<command>diskinfo -V</command> zu vergleichen.  Ein Laufwerk
	mit größerer Kapazität wird funktionieren, allerdings wird der
	zusätzliche Platz ungenutzt bleiben.</para>

      <para>Nachdem der Rechner wieder eingeschaltet ist, wird der
	Spiegel im <quote>degraded</quote> Modus ausgeführt werden.
	Der Spiegel wird angewiesen, Laufwerke zu vergessen, die noch
	nicht verbunden sind:</para>

      <screen>&prompt.root; <userinput>gmirror forget gm0</userinput></screen>

      <para>Alte Metadaten sollten von der Ersatzfestplatte nach den
	Anweisungen in <xref linkend="geom-mirror-metadata"/> gelöscht
	werden.  Anschließend kann die Ersatzfestplatte, in diesem
	Beispiel <filename>ada4</filename>, in den Spiegel eingefügt
	werden:</para>

      <screen>&prompt.root; <userinput>gmirror insert gm0 /dev/ada4</userinput></screen>

      <para>Die Wiederherstellung beginnt, sobald das neue Laufwerk in
	den Spiegel eingesetzt wird.  Das Kopieren der Daten vom
	Spiegel auf das neue Laufwerk kann eine Weile dauern.  Die
	Leistung des Spiegels ist während dieser Zeit stark reduziert,
	deswegen sollten neue Laufwerke idealerweise dann eingefügt
	werden, wenn der Rechner nicht benötigt wird.</para>

      <para>Der Fortschritt der Wiederherstellung kann mit
	<command>gmirror status</command> überwacht werden.  Während
	der Wiederherstellung ist der Status
	<computeroutput>DEGRADED</computeroutput>.  Wenn der Vorgang
	abgeschlossen ist, wechselt der Status zu
	<computeroutput>COMPLETE</computeroutput>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-raid3">
    <info>

      <title><acronym>RAID</acronym>3 - Byte-Level Striping mit
	dedizierter Parität</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mark</firstname>
	    <surname>Gladman</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Daniel</firstname>
	    <surname>Gerzo</surname>
	  </personname>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Basierend auf Dokumentation von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Murray</firstname>
	    <surname>Stokely</surname>
	  </personname>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Björn</firstname>
	    <surname>Heidotting</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>RAID3</primary>
    </indexterm>

    <para><acronym>RAID</acronym>3 ist eine Methode, die mehrere
      Festplatten zu einem einzigen Volume mit einer dedizierten
      Paritätsfestplatte kombiniert.  In einem
      <acronym>RAID</acronym>3-System werden die Daten in einzelne
      Bytes aufgeteilt und dann über alle Laufwerke,
      mit Ausnahme der Paritätsfestplatte, geschrieben.  Beim Lesen
      von Daten in einer <acronym>RAID</acronym>3 Implementierung
      werden alle Festplatten im Array parallel genutzt.  Die Leistung
      kann durch den Einsatz von mehreren Controllern weiter erhöht
      werden.  Ein <acronym>RAID</acronym>3-Array hat eine
      Fehlertoleranz von 1 Laufwerk und bietet dabei eine Kapazität
      von 1 - 1/n der Gesamtkapazität der Laufwerke im Array, wobei
      n die Anzahl der Festplatten im Array darstellt.  So eine
      Konfiguration ist meistens für die Speicherung von größeren
      Dateien geeignet, wie beispielsweise Multimediadateien.</para>

    <para>Mindestens 3 Festplatten sind erforderlich, um ein
      <acronym>RAID</acronym>3 zu erstellen.  Jede Festplatte muss
      von der gleichen Größe sein, da die
      <acronym>I/O</acronym>-Anfragen für Lesen oder Schreiben
      auf mehreren Festplatten parallel stattfinden.  Aufgrund der
      Beschaffenheit von <acronym>RAID</acronym>3, muss die Anzahl der
      Laufwerke 3, 5, 9, 17 bzw. 2^n + 1 sein.</para>

    <para>Dieser Abschnitt beschreibt, wie ein Software
      <acronym>RAID</acronym>3 auf einem &os;-System erstellt
      wird.</para>

    <note>
      <para>Obwohl es theoretisch möglich ist &os; von einem
	<acronym>RAID</acronym>3-Array zu booten, wird von solch
	einer ungewöhnlichen Konfiguration dringend abgeraten.</para>
    </note>

    <sect2>
      <title>Ein dediziertes <acronym>RAID</acronym>3-Array
	erstellen</title>

      <para>In &os; wird die Unterstützung für
	<acronym>RAID</acronym>3 über die
	<acronym>GEOM</acronym>-Klasse &man.graid3.8; implementiert.
	Zum Erstellen eines dedizierten
	<acronym>RAID</acronym>3-Arrays sind folgende Schritte
	erforderlich.</para>

      <procedure>
	<step>
	  <para>Laden Sie zunächst das Modul
	    <filename>geom_raid3.ko</filename> mit einem der folgenden
	    Befehle:</para>

	  <screen>&prompt.root; <userinput>graid3 load</userinput></screen>

	  <para>oder:</para>

	  <screen>&prompt.root; <userinput>kldload geom_raid3</userinput></screen>
	</step>

	<step>
	  <para>Stellen Sie sicher, dass ein geeigneter Mountpunkt
	    existiert.  Dieser Befehl erstellt ein neues Verzeichnis,
	    welches als Mountpunkt verwendet werden kann:</para>

	  <screen>&prompt.root; <userinput>mkdir <replaceable>/multimedia</replaceable></userinput></screen>
	</step>

	<step>
	  <para>Bestimmen Sie die Gerätenamen der Festplatten, die dem
	    Array hinzugefügt werden und erstellen Sie ein neues
	    <acronym>RAID</acronym>3 Gerät.  Das letzte aufgeführte
	    Gerät wird als dediziertes Paritätslaufwerk verwendet.
	    Dieses Beispiel verwendet drei unpartionierte
	    <acronym>ATA</acronym>-Platten:
	    <filename><replaceable>ada1</replaceable></filename> und
	    <filename><replaceable>ada2</replaceable></filename> für
	    die Daten, sowie
	    <filename><replaceable>ada3</replaceable></filename> für
	    die Parität.</para>

	  <screen>&prompt.root; <userinput>graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</userinput>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</screen>
	</step>

	<step>
	  <para>Partitionieren Sie das neu erstelle Gerät
	    <filename>gr0</filename> und erstellen Sie darauf
	    ein <acronym>UFS</acronym>-Dateisystem:</para>

	  <screen>&prompt.root; <userinput>gpart create -s GPT /dev/raid3/gr0</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs /dev/raid3/gr0</userinput>
&prompt.root; <userinput>newfs -j /dev/raid3/gr0p1</userinput></screen>

	  <para>Viele Zahlen rauschen nun über den Bildschirm und
	    nach einer gewissen Zeit ist der Vorgang abgeschlossen.
	    Das Volume wurde erstellt und kann jetzt in den
	    Verzeichnisbaum eingehangen werden:</para>

	  <screen>&prompt.root; <userinput>mount /dev/raid3/gr0p1 /multimedia/</userinput></screen>

	  <para>Das <acronym>RAID</acronym>3-Array ist nun
	    einsatzbereit.</para>
	</step>
      </procedure>

      <para>Weitere Konfigurationsschritte sind erforderlich, um die
	Einstellungen nach einem Systemneustart zu erhalten.</para>

      <procedure>
	<step>
	  <para>Das Modul <filename>geom_raid3.ko</filename> muss
	    geladen werden, bevor das Array eingehangen werden kann.
	    Damit das Kernelmodul automatisch beim Systemstart geladen
	    wird, muss die folgende Zeile in
	    <filename>/boot/loader.conf</filename> hinzugefügt
	    werden:</para>

	  <programlisting>geom_raid3_load="YES"</programlisting>
	</step>

	<step>
	  <para>Die folgenden Informationen über das Volume müssen in
	    <filename>/etc/fstab</filename> hinzugefügt werden, um
	    das Dateisystem des Arrays automatisch beim Systemstart
	    zu aktivieren:</para>

	  <programlisting>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</programlisting>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-graid">
    <info>
      <title>Software <acronym>RAID</acronym></title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Warren</firstname>
	    <surname>Block</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Björn</firstname>
	    <surname>Heidotting</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Software RAID</primary>
      <secondary>Hardware RAID</secondary>
    </indexterm>

    <para>Einige Motherboards und Erweiterungskarten besitzen ein
      <acronym>ROM</acronym>, das dem Rechner erlaubt von einem
      <acronym>RAID</acronym>-Array zu booten.  Nach dem Booten wird
      der Zugriff auf das <acronym>RAID</acronym>-Array durch die
      Software auf dem Prozessor des Rechners abgewickelt.  Dieses
      <quote>Hardware-unterstützte
	Software-<acronym>RAID</acronym></quote> ist nicht abhängig
      von einem bestimmten Betriebssystem.  Sie funktionieren bereits,
      noch bevor das Betriebssystem geladen wird.</para>

    <para>Abhängig von der verwendeten Hardware werden mehrere Arten
      von <acronym>RAID</acronym> unterstützt.  Eine vollständige
      Liste finden Sie in &man.graid.8;.</para>

    <para>&man.graid.8; benötigt das <filename>geom_raid.ko</filename>
      Kernelmodul, welches beginnend mit &os;&nbsp;9.1 im
      <filename>GENERIC</filename>-Kernel enthalten ist.  Bei Bedarf
      kann es manuell mit <command>graid load</command> geladen
      werden.</para>

    <sect2 xml:id="geom-raid-creating">
      <title>Ein Array erstellen</title>

      <para>Geräte mit Software-<acronym>RAID</acronym> haben oft ein
	Menü, das über eine bestimmte Tastenkombination beim Booten
	aufgerufen werden kann.  Das Menü kann verwendet werden, um
	<acronym>RAID</acronym>-Arrays zu erstellen und zu löschen.
	Mit &man.graid.8; können Arrays auch direkt von der
	Kommandozeile erstellt werden.</para>

      <para><command>graid label</command> wird verwendet, um ein
	neues Array zu erstellen.  Das Motherboard in diesem Beispiel
	besitzt einen &intel; Software-<acronym>RAID</acronym>
	Chipsatz, so dass das Metadatenformat von &intel; angegeben
	wird.  Das neue Array bekommt den Namen (Label)
	<filename>gm0</filename>, verhält sich als Spiegel
	(<acronym>RAID1</acronym>) und verwendet die Laufwerke
	<filename>ada0</filename> und
	<filename>ada1</filename>.</para>

      <caution>
	<para>Bei der Erstellung des Arrays wird etwas Platz auf den
	  Laufwerken überschrieben.  Sichern Sie zuvor alle
	  vorhandenen Daten!</para>
      </caution>

      <screen>&prompt.root; <userinput>graid label Intel gm0 RAID1 ada0 ada1</userinput>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created$
GEOM_RAID: Intel-a29ea104: Provider raid/r0 for volume gm0 created.</screen>

      <para>Eine Statusabfrage zeigt, dass der neue Spiegel
	einsatzbereit ist:</para>

      <screen>&prompt.root; <userinput>graid status</userinput>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))
                  ada1 (ACTIVE (ACTIVE))</screen>

      <para>Das Array-Gerät erscheint in
	<filename>/dev/raid/</filename>.  Das erste Gerät heißt
	<filename>r0</filename>.  Falls weitere Geräte vorhanden sind
	heißen diese <filename>r1</filename>, <filename>r2</filename>
	und so weiter.</para>

      <para>Das <acronym>BIOS</acronym>-Menü einiger Geräte erstellt
	Arrays mit Sonderzeichen im Namen.  Um Probleme mit diesen
	Sonderzeichen zu vermeiden, werden einfache numerische Namen
	wie <filename>r0</filename> vergeben.  Um das tatsächliche
	Label anzuzeigen, wie <filename>gm0</filename> im obigen
	Beispiel, benutzen Sie &man.sysctl.8;:</para>

      <screen>&prompt.root; <userinput>sysctl kern.geom.raid.name_format=1</userinput></screen>
    </sect2>

    <sect2 xml:id="geom-graid-volumes">
      <title>Mehrere Volumes</title>

      <para>Einige Software-<acronym>RAID</acronym> Geräte
	unterstützen mehr als ein <emphasis>Volume</emphasis> pro
	Array.  Volumes funktionieren wie Festplatten, dass heißt der
	Platz auf den Laufwerken kann auf unterschiedliche Weise
	geteilt und genutzt werden.  Intels
	Software-<acronym>RAID</acronym> Geräte unterstützen
	beispielsweise zwei Volumes.  In diesem Beispiel wird ein
	40&nbsp;GB Spiegel verwendet um das Betriebssystem zu
	speichern, gefolgt von einem 20&nbsp;GB
	<acronym>RAID0</acronym> (Stripe) Volume für die schnelle
	Speicherung von temporären Daten.</para>

      <screen>&prompt.root; <userinput>graid label -S 40G Intel gm0 RAID1 ada0 ada1</userinput>
&prompt.root; <userinput>graid add -S 20G gm0 RAID0</userinput></screen>

      <para>Volumes erscheinen unter <filename>/dev/raid/</filename>
	als zusätzliche Einträge
	<filename>r<replaceable>X</replaceable></filename>.  Ein
	Array mit Volumes wird als <filename>r0</filename> und
	<filename>r1</filename>.</para>

      <para>Lesen Sie &man.graid.8; um die Anzahl der Volumes zu
	ermitteln, die von den verschiedenen
	Software-<acronym>RAID</acronym> Geräten unterstützt
	wird.</para>
    </sect2>

    <sect2 xml:id="geom-graid-converting">
      <title>Ein einzelnes Laufwerk zu einem Spiegel
	konvertieren</title>

      <para>Unter bestimmten Umständen ist es möglich, ein
	bestehendes Laufwerk ohne Neuformatierung zu einem
	&man.graid.8; Array zu konvertieren.  Um Datenverlust
	bei der Konvertierung zu vermeiden, müssen die vorhandenen
	Laufwerke folgende Mindestanforderungen erfüllen:</para>

      <itemizedlist>
	<listitem>
	  <para>Das Laufwerk muss mit <acronym>MBR</acronym>
	    partitioniert werden.  <acronym>GPT</acronym> oder andere
	    Partitionierungsschemata funktionieren nicht, da durch
	    &man.graid.8; die Metadaten am Ende des Laufwerks
	    überschieben und beschädigt werden.</para>
	</listitem>

	<listitem>
	  <para>Am Ende des Laufwerks muss genügend freier Platz zur
	    Verfügung stehen, um die &man.graid.8; Metadaten zu
	    speichern.  Die Metadaten variieren in der Größe, es
	    werden jedoch mindestens 64&nbsp;MB freier Speicherplatz
	    empfohlen.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn das Laufwerk diese Anforderungen erfüllt, erstellen
	Sie zuerst eine vollständige Sicherung.  Erzeugen Sie dann
	einen Spiegel mit diesem einen Laufwerk:</para>

      <screen>&prompt.root; <userinput>graid label Intel gm0 RAID1 ada0 NONE</userinput></screen>

      <para>Die Metadaten von &man.graid.8; werden in den ungenutzten
	Raum am Ende des Laufwerks geschrieben.  Ein zweites Laufwerk
	kann nun in den Spiegel eingefügt werden:</para>

      <screen>&prompt.root; <userinput>graid insert raid/r0 ada1</userinput></screen>

      <para>Die Daten von dem ersten Laufwerk werden direkt auf das
	zweite Laufwerk kopiert.  Der Spiegel wird im eingeschränkten
	Zustand laufen, bis der Kopiervorgang abgeschlossen
	ist.</para>
    </sect2>

    <sect2 xml:id="geom-graid-inserting">
      <title>Neue Laufwerke zum Array hinzufügen</title>

      <para>Laufwerke in einem Array können für ausgefallene oder
	fehlende Laufwerke eingesetzt werden.  Falls es keine
	ausgefallenen oder fehlenden Laufwerke gibt, wird das neue
	Laufwerk als Ersatz (<foreignphrase>Spare</foreignphrase>)
	verwendet.</para>

      <para>Das Array in diesem Beispiel beginnt sofort damit, die
	Daten auf das neu hinzugefügte Laufwerk zu kopieren.  Alle
	vorhandenen Daten auf dem neuen Laufwerk werden
	überschrieben.</para>

      <screen>&prompt.root; <userinput>graid insert raid/r0 ada1</userinput>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</screen>
    </sect2>

    <sect2 xml:id="geom-graid-removing">
      <title>Laufwerke aus dem Array entfernen</title>

      <para>Einzelne Laufwerke können permanent aus dem Array entfernt
	werden.  Die Metadaten werden dabei gelöscht:</para>

      <screen>&prompt.root; <userinput>graid remove raid/r0 ada1</userinput>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</screen>
    </sect2>

    <sect2 xml:id="geom-graid-stopping">
      <title>Das Array anhalten</title>

      <para>Ein Array kann angehalten werden, ohne die Metadaten
	von den Laufwerken zu löschen.  Das Array wird wieder
	anlaufen, wenn das System neu gestartet wird.</para>

      <screen>&prompt.root; <userinput>graid stop raid/r0</userinput></screen>
    </sect2>

    <sect2 xml:id="geom-graid-status">
      <title>Den Status des Arrays überprüfen</title>

      <para>Der Status des Arrays kann jederzeit überprüft werden.
	Nachdem ein Laufwerk zum Array hinzugefügt wurde, werden die
	Daten vom ursprünglichen Laufwerk auf das neue Laufwerk
	kopiert:</para>

      <screen>&prompt.root; <userinput>graid status</userinput>
   Name    Status  Components
raid/r0  DEGRADED  ada0 (ACTIVE (ACTIVE))
                   ada1 (ACTIVE (REBUILD 28%))</screen>

      <para>Andere Arten von Arrays, wie <literal>RAID0</literal> oder
	<literal>CONCAT</literal>, werden den Status eines
	fehlgeschlagenen Laufwerks vielleicht nicht anzeigen.  Um
	diese teilweise ausgefallenen Arrays anzuzeigen, fügen Sie
	<option>-ga</option> hinzu:</para>

      <screen>&prompt.root; <userinput>graid status -ga</userinput>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 (ACTIVE (ACTIVE))</screen>
    </sect2>

    <sect2 xml:id="geom-graid-deleting">
      <title>Arrays löschen</title>

      <para>Arrays werden zerstört, indem alle Volumes gelöscht
	werden.  Wenn das letzte Volume gelöscht wird, wird das
	Array gestoppt und die Metadaten von den Laufwerken
	entfernt:</para>

      <screen>&prompt.root; <userinput>graid delete raid/r0</userinput></screen>
    </sect2>

    <sect2 xml:id="geom-graid-unexpected">
      <title>Unerwartete Arrays löschen</title>

      <para>Laufwerke können unerwartete &man.graid.8; Metadaten
	enthalten, entweder aus früherer Nutzung oder aus Tests des
	Herstellers.  &man.graid.8; würde diese Metadaten erkennen und
	daraus ein Array erstellen, was den Zugriff auf die einzelnen
	Laufwerke beeinträchtigen würde.  Um die unerwünschten
	Metadaten zu entfernen:</para>

      <procedure>
	<step>
	  <para>Booten Sie das System.  Im Boot-Menü wählen Sie
	    <literal>2</literal> für den Loader-Prompt.  Geben Sie
	    dann folgendes ein:</para>

	  <screen>OK <userinput>set kern.geom.raid.enable=0</userinput>
OK <userinput>boot</userinput></screen>

	  <para>Das System wird nun mit deaktiviertem &man.graid.8;
	    starten.</para>
	</step>

	<step>
	  <para>Sichern Sie alle Daten auf dem betroffenen
	    Laufwerk.</para>
	</step>

	<step>
	  <para>Zur Abhilfe kann auch die Array-Erkennung von
	    &man.graid.8; deaktiviert werden, indem</para>

	  <programlisting>kern.geom.raid.enable=0</programlisting>

	  <para>in <filename>/boot/loader.conf</filename> hinzugefügt
	    wird.</para>

	  <para>Um die &man.graid.8; Metadaten von dem entsprechenden
	    Laufwerk zu entfernen, booten Sie vom &os;
	    Installationsmedium und wählen Sie
	    <literal>Shell</literal> aus.  Benutzen Sie
	    <command>status</command>, um den Namen des Arrays zu
	    bestimmten, typischerweise
	    <literal>raid/r0</literal>:</para>

	  <screen>&prompt.root; <userinput>graid status</userinput>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))
                  ada1 (ACTIVE (ACTIVE))</screen>

	  <para>Löschen Sie das Volume:</para>

	  <screen>&prompt.root; <userinput>graid delete raid/r0</userinput></screen>

	  <para>Wiederholen Sie den Vorgang für jedes Volume.  Nachdem
	    das letzte Volume gelöscht wurde, wird das Volume
	    zerstört.</para>

	  <para>Starten Sie das System neu und prüfen die
	    Vollständigkeit der Daten.  Falls erforderlich, müssen die
	    Daten aus der Sicherung wiederhergestellt werden.  Nachdem
	    die Metadaten entfernt wurden, kann auch der Eintrag
	    <literal>kern.geom.raid.enable=0</literal> aus
	    <filename>/boot/loader.conf</filename> entfernt
	    werden.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-ggate">
    <title><acronym>GEOM</acronym> Gate Netzwerk</title>

    <para><acronym>GEOM</acronym> unterstützt einen einfachen
      Mechanismus für den Zugriff auf entfernte Geräte wie
      Festplatten, <acronym>CD</acronym>s und Dateien, durch die
      Verwendung des <acronym>GEOM</acronym> Gate Netzwerk Daemons,
      <application>ggated</application>.  Der Server-Dameon läuft auf
      dem System, welches ein Gerät anbietet und bearbeitet die
      <application>ggatec</application>-Anfragen der Clients.  Die
      Geräte sollten keine sensiblen Daten enthalten, da die
      Verbindung zwischen Client und Server nicht verschlüsselt
      ist.</para>

    <para>Ähnlich wie bei <acronym>NFS</acronym>, das in <xref
	linkend="network-nfs"/> beschrieben ist, wird für die
      Konfiguration von <application>ggated</application> eine
      Exportdatei verwendet.  Diese Datei legt fest, welche Systeme
      auf die exportierten Ressourcen zugreifen können und in welchem
      Umfang der Zugriff gestattet wird.  Um dem Client <systemitem
	class="ipaddress">192.168.1.5</systemitem> Lese- und
      Schreibzugriff auf die vierte Slice der ersten
      <acronym>SCSI</acronym>-Platte zu geben, erstellen Sie
      <filename>/etc/gg.exports</filename> mit folgender Zeile:</para>

    <programlisting>192.168.1.5 RW /dev/da0s4d</programlisting>

    <para>Bevor das Gerät exportiert werden kann, müssen Sie
      sicherstellen, dass es nicht bereits gemountet ist.
      Anschließend starten Sie
      <application>ggated</application>.</para>

    <screen>&prompt.root; <userinput>ggated</userinput></screen>

    <para>Es stehen mehrere Optionen bereit, mit denen zum Beispiel
      ein alternativer Port oder eine alternative Exportdatei
      festgelegt werden kann.  Weitere Einzelheiten finden Sie in
      &man.ggated.8;.</para>

    <para>Damit ein Client auf das exportierte Gerät zugreifen kann,
      benutzten Sie <application>ggatec</application> zusammen mit der
      <acronym>IP</acronym>-Adresse des Servers und dem entsprechenden
      Gerätenamen.  Wenn dies erfolgreich ist, zeigt dieser Befehl
      einen <literal>ggate</literal>-Gerätenamen.  Hängen Sie dieses
      Gerät in einen freien Mountpunkt ein.  Dieses Beispiel verbindet
      sich mit der Partition <filename>/dev/da0s4d</filename> auf
      <literal>192.168.1.1</literal> und hängt
      <filename>/dev/ggate0</filename> in <filename>/mnt</filename>
      ein:</para>

    <screen>&prompt.root; <userinput>ggatec create -o rw 192.168.1.1 /dev/da0s4d</userinput>
ggate0
&prompt.root; <userinput>mount /dev/ggate0 /mnt</userinput></screen>

    <para>Auf das Gerät des Servers kann jetzt über den Mountpunkt
      <filename>/mnt</filename> des Clients zugegriffen werden.
      Weitere Informationen über <command>ggatec</command> und einige
      Anwendungsbeispiele finden Sie in &man.ggatec.8;.</para>

    <note>
      <para>Das Einhängen des Gerätes wird scheitern, falls das Gerät
	momentan entweder auf dem Server oder einem Client im Netzwerk
	gemountet ist.  Wenn ein gleichzeitiger Zugriff auf die
	Netzwerkressourcen benötigt wird, verwenden Sie stattdessen
	<acronym>NFS</acronym>.</para>
    </note>

    <para>Wenn das Gerät nicht länger gebraucht wird, kann es mit
      &man.umount.8; ausgehängt werden, so dass die Ressourcen für
      andere Client wieder verfügbar sind.</para>
  </sect1>

  <sect1 xml:id="geom-glabel">
    <title>Das Labeln von Laufwerken</title>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Disk Labels</primary>
    </indexterm>

    <para>Während der Initialisierung des Systems legt der
      &os;-Kernel für jedes gefundene Gerät Knotenpunkte
      an.  Diese Methode für die Überprüfung auf
      vorhandene Geräte wirft einige Fragen auf.  Was passiert
      beispielsweise, wenn ein neues
      <acronym>USB</acronym>-Laufwerk hinzugefügt wird?
      Es ist sehr wahrscheinlich, dass ein
      Flash-Speicher-Gerät den Gerätenamen
      <filename>da0</filename> erhält, während
      gleichzeitig das bisherige <filename>da0</filename>
      zu <filename>da1</filename> wird.  Dies verursacht
      Probleme beim Einhängen von Dateisystemen, wenn diese
      in <filename>/etc/fstab</filename> aufgeführt sind und kann dazu
      führen, dass das System nicht mehr startet.</para>

    <para>Eine Lösung für dieses Problem ist das
      Aneinanderketten der <acronym>SCSI</acronym>-Geräte,
      damit ein neues Gerät, welches der
      <acronym>SCSI</acronym>-Karte hinzugefügt wird,
      unbenutzte Gerätenummern erhält.  Aber was
      geschieht, wenn ein <acronym>USB</acronym>-Gerät
      möglicherweise die primäre
      <acronym>SCSI</acronym>-Platte ersetzt? Dies kann
      passieren, weil <acronym>USB</acronym>-Geräte
      normalerweise vor der <acronym>SCSI</acronym>-Karte
      geprüft werden.  Eine Lösung ist das
      Hinzufügen dieser Geräte, nachdem das System
      gestartet ist.  Eine andere Lösung könnte sein,
      nur ein einzelnes <acronym>ATA</acronym>-Laufwerk zu
      nutzen und die <acronym>SCSI</acronym>-Geräte niemals
      in der <filename>/etc/fstab</filename> aufzuführen.</para>

    <para>Eine bessere Lösung ist die Verwendung von
      <command>glabel</command>, um die Laufwerke zu mit Labeln zu
      versehen und diese in <filename>/etc/fstab</filename> zu
      nutzen.  Da <command>glabel</command> seine Label im letzten
      Sektor jedes vorhandenen Datenträgers speichert, wird
      das Label persistent bleiben (auch über Neustarts hinweg).
      Durch Nutzung dieses Labels als Gerät kann das
      Dateisystem immer gemountet sein, unabhängig davon,
      durch welchen Geräte-Knotenpunkt auf ihn zugegriffen
      wird.</para>

    <note>
      <para><command>glabel</command> kann permanente (dauerhaft) und
	vorübergehende Label erstellen.  Aber nur dauerhafte
	Label bleiben konsistent über Neustarts hinweg. Lesen
	Sie die &man.glabel.8; für weitere Unterschiede zwischen den
	Label-Typen.</para>
    </note>

    <sect2>
      <title>Label-Typen und Beispiele</title>

      <para>Permanente Label können generische Label oder
	Dateisystem-Label sein.  Permanente Dateisystem-Label können
	mit &man.tunefs.8; oder &man.newfs.8; erzeugt werden.  Dieser
	Typ von Label wird in einem Unterverzeichnis von
	<filename>/dev</filename> angelegt und wird dem Dateisystem
	entsprechend benannt.
	<acronym>UFS</acronym>2-Dateisystem-Label werden zum Beispiel
	in <filename>/dev/ufs</filename> angelegt.  Permanente Label
	können außerdem durch den Befehl
	<command>glabel label</command> erzeugt werden.  Diese Label
	sind nicht dateisystemspezisch und werden im Unterverzeichnis
	<filename>/dev/label</filename> erzeugt.</para>

      <para>Temporäre Label werden beim nächsten Systemstart zerstört.
	Diese Label werden im Verzeichnis
	<filename>/dev/label</filename> erzeugt und sind ideal für
	Testzwecke.  Ein temporäres Label kann mit
	<command>glabel create</command> erzeugt werden.</para>

<!-- XXXTR: How do you create a file system label without running newfs
            or when there is no newfs (e.g.: cd9660)? -->

      <para>Um ein permanentes Label auf einem
	<acronym>UFS</acronym>2-Dateisystem ohne
	Löschung von Daten zu erzeugen, kann man folgenden
	Befehl verwenden:</para>

      <screen>&prompt.root; <userinput>tunefs -L <replaceable>home</replaceable> <replaceable>/dev/da3</replaceable></userinput></screen>

      <para>In <filename>/dev/ufs</filename> sollte nun ein Label
	vorhanden sein, welches zu <filename>/etc/fstab</filename>
	hinzugefügt werden kann:</para>

      <programlisting>/dev/ufs/home		/home            ufs     rw              2      2</programlisting>

      <note>
	<para>Das Dateisystem darf nicht gemountet sein beim
	  Versuch, <command>tunefs</command> auszuführen.</para>
      </note>

      <para>Nun kann das Dateisystem eingehängt werden:</para>

      <screen>&prompt.root; <userinput>mount /home</userinput></screen>

      <para>Von nun an kann der Geräte-Knotenpunkt sich ohne
	negative Effekte auf das System ändern, solange das
	Kernelmodul <filename>geom_label.ko</filename> beim
	Systemstart mittels <filename>/boot/loader.conf</filename>
	geladen wird oder die
	<literal>GEOM_LABEL</literal>-Kernel-Option aktiv ist.</para>

      <para>Dateisysteme können auch mit einem Standard-Label
	erzeugt werden (mittels des Flags <option>-L</option> in
	<command>newfs</command>).  Lesen Sie &man.newfs.8; für
	weitere Informationen.</para>

      <para>Der folgende Befehl kann genutzt werden, um das Label
	zu beseitigen:</para>

      <screen>&prompt.root; <userinput>glabel destroy home</userinput></screen>

      <para>Das folgende Beispiel zeigt Ihnen, wie Sie Label für
	die Partitionen einer Bootplatte erzeugen.</para>

      <example>
	<title>Die Partitionen einer Bootplatte labeln</title>

	<para>Durch das Erstellen von permanenten Labeln für die
	  Partitionen einer Bootplatte sollte das System selbst dann
	  noch normal starten können, wenn Sie die Platte an einen
	  anderen Controller anschließen oder in ein anderes System
	  installieren.  In diesem Beispiel nehmen wir an, dass nur
	  eine einzige <acronym>ATA</acronym>-Platte verwendet wird,
	  die das System derzeit als <filename>ad0</filename>
	  erkennt.  Weiters nehmen wir an, dass Sie das
	  Standard-Partionierungsschema von &os; vewendet haben und
	  die Platte daher die Dateisysteme <filename>/</filename>,
	  <filename>/var</filename>, <filename>/usr</filename> sowie
	  <filename>/tmp</filename> aufweist.  Zusätzlich wurde eine
	  Swap-Partition angelegt.</para>

	<para>Starten Sie das System neu.  Am &man.loader.8;-Prompt
	  drücken Sie die Taste <keycap>4</keycap>, um in den
	  Single-User-Modus zu gelangen.  Dort führen Sie die
	  folgenden Befehle aus:</para>

	<screen>&prompt.root; <userinput>glabel label rootfs /dev/ad0s1a</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs
&prompt.root; <userinput>glabel label var /dev/ad0s1d</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1d is label/var
&prompt.root; <userinput>glabel label usr /dev/ad0s1f</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr
&prompt.root; <userinput>glabel label tmp /dev/ad0s1e</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp
&prompt.root; <userinput>glabel label swap /dev/ad0s1b</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap
&prompt.root; <userinput>exit</userinput></screen>

	<para>Das System startet daraufhin in den Multi-User-Modus.
	  Nachdem der Startvorgang abgeschlossen ist, editieren Sie
	  <filename>/etc/fstab</filename> und ersetzen die
	  konventionellen Gerätedateien durch die entsprechenden
	  Label.  Die modifizierte <filename>/etc/fstab</filename>
	  sollte wie folgt aussehen:</para>

	<programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</programlisting>

	<para>Starten Sie das System neu.  Treten keine Probleme auf,
	  wird das System normal hochfahren und Sie erhalten die
	  folgende Ausgabe, wenn Sie den Befehl
	  <command>mount</command> ausführen:</para>

	<screen>&prompt.root; <userinput>mount</userinput>
/dev/label/rootfs on / (ufs, local)
devfs on /dev (devfs, local)
/dev/label/tmp on /tmp (ufs, local, soft-updates)
/dev/label/usr on /usr (ufs, local, soft-updates)
/dev/label/var on /var (ufs, local, soft-updates)</screen>
      </example>

      <para>&man.glabel.8; unterstützt einen Labeltyp für
	<acronym>UFS</acronym>-Dateisysteme.  Dieser basiert auf der
	eindeutigen Dateisystem-ID <literal>ufsid</literal>.
	Derartige Label finden sich in
	<filename>/dev/ufsid</filename> und werden
	während des Systemstarts automatisch erzeugt.  Es ist
	möglich, diese <literal>ufsid</literal>-Label zum
	automatischen Einhängen von Partitionen in
	<filename>/etc/fstab</filename> einzusetzen.  Verwenden Sie
	<command>glabel status</command>, um eine Liste
	aller Dateisysteme und ihrer <literal>ufsid</literal>-Label
	zu erhalten:</para>

      <screen>&prompt.user; <userinput>glabel status</userinput>
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</screen>

      <para>In diesem Beispiel repräsentiert
	<filename>ad4s1d</filename> das
	<filename>/var</filename>-Dateisystem,
	während <filename>ad4s1f</filename> dem
	<filename>/usr</filename>-Dateisystem
	entspricht.  Wenn Sie die angegebenen
	<literal>ufsid</literal>-Werte verwenden, können
	diese Dateisysteme durch die folgenden Einträge in
	der Datei <filename>/etc/fstab</filename> gemountet
	werden:</para>

      <programlisting>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</programlisting>

      <para>Jede Partition, die ein <literal>ufsid</literal>-Label
	aufweist, kann auf diese Art gemountet werden.  Dies hat den
	Vorteil, dass Sie die permanenten Label nicht manuell anlegen
	müssen, wobei sich die Platten nach wie vor über
	geräteunabhängige Namen ansprechen und einhängen
	lassen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-gjournal">
    <title>UFS Journaling in <acronym>GEOM</acronym></title>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Journaling</primary>
    </indexterm>

    <para>&os; unterstützt Journaling für
      <acronym>UFS</acronym>-Dateisysteme.  Diese Funktion wird über
      das <acronym>GEOM</acronym>-Subsystem realisiert und kann
      über das Werkzeug &man.gjournal.8; eingerichtet werden.  Im
      Gegensatz zu anderen Journaling-Dateisystemen arbeitet
      <command>gjournal</command> blockbasiert und wurde nicht als
      Teil des Dateisystems implementiert, sondern als
      <acronym>GEOM</acronym>-Erweiterung.</para>

    <para>Bei Journaling wird ein Protokoll über alle
      Dateisystemtransaktionen angelegt, inklusive aller
      Veränderungen, aus denen ein kompletter Schreibvorgang besteht,
      bevor diese Änderungen (Metadaten sowie tatsächliche
      Schreibvorgänge) physisch auf der Festplatte ausgeführt werden.
      Dieses Protokoll kann später erneut aufgerufen werden, um diese
      Vorgänge zu wiederholen, damit Systeminkonsistenzen vermieden
      werden.</para>

    <para>Diese Technik bietet eine weitere Möglichkeit,
      sich vor Datenverlust und Dateisystem-Inkonsistenzen zu
      schützen.  Im Gegensatz zu Soft Updates (die
      Metadaten-Aktualisierungen verfolgen und erzwingen) und
      Snapshots (die ein Image eines Dateisystems darstellen) wird
      bei Journaling ein tatsächliches Protokoll in einem speziell
      dafür bereitgestellten Bereich der Festplatte gespeichert.  Um
      die Leistung zu optimieren, kann das Journal auf eine externe
      Platte ausgelagert werden.  In einem solchen Fall geben Sie die
      Gerätedatei der Platte nach dem Gerät an, für das Sie Journaling
      aktivieren wollen.</para>

    <para>Der <filename>GENERIC</filename>-Kernel bietet Unterstützung
      für <command>gjournal</command>.  Damit das Kernelmodul
      <filename>geom_journal.ko</filename> beim Booten automatisch
      geladen wird, fügen Sie folgende Zeile in
      <filename>/boot/loader.conf</filename> hinzu:</para>

    <programlisting>geom_journal_load="YES"</programlisting>

    <para>Wenn ein angepasster Kernel benutzt wird, stellen Sie
      sicher, dass folgende Zeile in der Kernelkonfigurationsdatei
      enthalten ist:</para>

    <programlisting>options     GEOM_JOURNAL</programlisting>

    <para>Sobald das Modul geladen ist, kann ein Journal auf einem
      neuen Dateisystem erstellt werden.  In diesem Beispiel ist
      <filename>da4</filename> die neue
      <acronym>SCSI</acronym>-Platte:</para>

    <screen>&prompt.root; <userinput>gjournal load</userinput>
&prompt.root; <userinput>gjournal label /dev/<replaceable>da4</replaceable></userinput></screen>

    <para>Diese Befehle laden das Modul und erstellen die Gerätedatei
      <filename>/dev/da4.journal</filename> auf
      <filename>/dev/da4</filename>.</para>

    <para>Nun kann auf dem neuen Gerät ein
      <acronym>UFS</acronym>-Dateisystem erstellt werden, welches dann
      in den Verzeichnisbaum eingehängt wird:</para>

    <screen>&prompt.root; <userinput>newfs -O 2 -J /dev/<replaceable>da4</replaceable>.journal</userinput>
&prompt.root; <userinput>mount /dev/<replaceable>da4</replaceable>.journal <replaceable>/mnt</replaceable></userinput></screen>

    <note>
      <para>Falls auf dem System mehrere Slices angelegt sind
	(beispielsweise <filename>ad4s1</filename> sowie
	<filename>ad4s2</filename>), wird
	<command>gjournal</command> für jedes Slice ein
	Journal anlegen (also <filename>ad4s1.journal</filename>
	sowie <filename>ad4s2.journal</filename>).</para>
    </note>

    <para>Mit <command>tunefs</command> ist es auch möglich,
      Journaling auf bereits existierenden Dateisystemen zu
      aktivieren.  Machen Sie aber <emphasis>immer</emphasis> eine
      Sicherung der Daten, bevor Sie versuchen, ein existierendes
      Dateisystem zu ändern.  <command>gjournal</command> wird zwar
      den Vorgang abbrechen, wenn es das Journal nicht erzeugen kann,
      allerdings schützt dies nicht vor Datenverlust durch einen
      fehlerhaften Einsatz von <command>tunefs</command>.  Weitere
      Informationen über diese beiden Werkzeuge finden Sie in
      &man.gjournal.8; und &man.tunefs.8;.</para>

    <para>Es ist möglich, Journale auch für die Bootplatte eines
      &os;-Systems zu verwenden.  Der Artikel <link
	xlink:href="&url.articles.gjournal-desktop.en;/article.html">
	Implementing UFS Journaling on a Desktop PC</link> enthält
      eine ausführliche Anleitung zu diesem Thema.</para>
  </sect1>
</chapter>

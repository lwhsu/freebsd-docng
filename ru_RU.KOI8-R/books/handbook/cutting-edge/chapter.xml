<?xml version="1.0" encoding="koi8-r"?>
<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/cutting-edge/chapter.xml,v 1.52 2006/06/20 18:02:32 marck Exp $

     Original revision: r47724
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="updating-upgrading">

  <info>
    <title>Обновление системы и смена версии &os;</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jim</firstname>
	  <surname>Mock</surname>
	</personname>
	<contrib>Реструктурирование, реорганизацию и частичное
	  обновление выполнил </contrib>
      </author>
      <!-- Март 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jordan</firstname>
	  <surname>Hubbard</surname>
	</personname>
	<contrib>Оригинальный текст написали </contrib>
      </author>

      <author>
	<personname>
	  <firstname>Poul-Henning</firstname>
	  <surname>Kamp</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>John</firstname>
	  <surname>Polstra</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	</personname>
      </author>
    </authorgroup>
    
    <authorgroup>
      <author>
	<personname>
	  <firstname>Андрей</firstname>
	  <surname>Захватов</surname>
	</personname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Краткий обзор</title>

    <para>Между релизами над &os; ведется постоянная работа.  Некоторые
      отдают предпочтение официально выпущенным версиям, в то время как
      остальные предпочитают использовать последние разработки.  Тем не
      менее, даже для официальных версий часто выходят обновления,
      связанные с безопасностью и другими критическими исправлениями.
      Независимо от используемой версии &os; предоставляет все необходимые
      инструменты для поддержания системы в актуальном состоянии, а также
      позволяет легко перейти на другую версию.  Эта глава описывает,
      как отслеживать систему в процессе её разработки, а также
      основные инструменты для поддержания системы &os; в актуальном
      состоянии.</para>

    <para>После чтения этой главы вы будете знать:</para>

    <itemizedlist>
      <listitem>
	<para>Как поддерживать систему &os; в актуальном состоянии при
	  помощи <application>freebsd-update</application>,
	  <application>Subversion</application>
	  или <application>CTM</application>.</para>
      </listitem>

      <listitem>
	<para>Как узнать состояние установленной системы по отношению к
	  известной нетронутой копии.</para>
      </listitem>

      <listitem>
	<para>Как поддерживать установленную документацию в актуальном
	  состоянии при помощи <application>Subversion</application>
	  или портов документации.</para>
      </listitem>

      <listitem>
	<para>Разницу между двумя ветвями разработки: &os.stable; и
	  &os.current;.</para>
      </listitem>

      <listitem>
	<para>Как перестраивать и переустанавливать всю базовую
	  систему.</para>
      </listitem>
    </itemizedlist>

    <para>Перед чтением этой главы вы должны:</para>

    <itemizedlist>
      <listitem>
	<para>Правильно настроить сетевое подключение
	  (<xref linkend="advanced-networking"/>).</para>
      </listitem>

      <listitem>
	<para>Знать, как устанавливать дополнительное стороннее
	  программное обеспечение (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>В этой главе для получения и обновления исходных текстов
	&os; используется команда <command>svn</command>.  Для этого
	нужно сперва установить порт или пакет
	<package>devel/subversion</package>.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info>
      <title>Обновление &os;</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Оригинальный текст написал </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Colin</firstname>
	    <surname>Percival</surname>
	  </personname>
	  <contrib>На основе заметок, которые предоставил </contrib>
	</author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>обновление и смена версии</primary>
    </indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>обновление и смена версии</see>
    </indexterm>

    <para>Своевременное применение обновлений безопасности и переход
      на более новую версию операционной системы &mdash; важные
      аспекты системного администрирования.  &os; включает в себя
      программу <command>freebsd-update</command>, которую можно
      использовать для решения обеих задач.</para>

    <para>Эта программа используется для установки распространяемых в
      двоичном виде обновлений безопасности и исправлений для &os;
      без необходимости ручной компиляции и установки патчей или
      нового ядра.  Двоичные обновления доступны для всех архитектур
      и версий, поддерживаемых группой безопасности.  Перечень
      поддерживаемых версий и их ожидаемые даты окончания поддержки
      указаны на странице <uri
	xlink:href="http://www.FreeBSD.org/security/">http://www.FreeBSD.org/security/</uri>.</para>

    <para>Эта программа также используется для незначительных
      обновлений версии операционной системы, а также для перехода на
      другую ветвь выпуска релизов.  Перед обновлением следует
      ознакомиться с объявлением о выпуске новой версии, так как там
      может содержаться важная информация, применимая к версии, на
      которую намечен переход.  С соответствующими объявлениями можно
      ознакомиться по ссылке <uri
	xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri>.</para>

    <note>
      <para>Если имеется задание <command>crontab</command>,
	запускающее &man.freebsd-update.8;, то перед сменой версии
	операционной системы его обязательно нужно выключить.</para>
    </note>

    <para>В этом разделе описывается конфигурационный файл
      <command>freebsd-update</command>, демонстрируется применение
      исправлений безопасности и обновление операционной системы со
      сменой младшей или старшей версии, а также обсуждаются некоторые
      соображения касаемо смены версии операционной системы.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>Конфигурационный файл</title>

      <para>Конфигурационный файл <command>freebsd-update</command>
	самодостаточен и работает по умолчанию.  Некоторые пользователи
	могут пожелать отредактировать конфигурационный файл
	<filename>/etc/freebsd-update.conf</filename> для лучшего
	контроля над процессом обновления.  В комментариях описываются
	доступные в этом файле параметры, но для следующих из них может
	потребоваться дополнительное разъяснение:</para>

      <programlisting># Components of the base system which should be kept updated.
Components world kernel</programlisting>

      <para>Данный параметр определяет, какие части &os; будут
	обновлены.  По умолчанию обновляется вся базовая система
	(world) и ядро (kernel).  Вместо этого можно указать отдельные
	компоненты, такие как <literal>src/base</literal> или
	<literal>src/sys</literal>.  Тем не менее, лучшим вариантом
	будет оставить всё как есть, поскольку изменение этого перечня
	с целью добавления особых пунктов потребует от пользователя
	указания подряд всех пунктов.  Со временем это может привести
	к негативным последствиям из-за возможной рассинхронизации
	между исходными текстами и двоичными файлами.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</programlisting>

      <para>Добавьте сюда пути к каталогам (например,
	<filename>/bin</filename> или <filename>/sbin</filename>),
	которые вы бы хотели оставить нетронутыми в процессе
	обновления.  Этот параметр можно использовать для
	предотвращения перезаписывания локальных изменений
	программой <command>freebsd-update</command>.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Этот параметр позволяет обновлять конфигурационные файлы
	в указанных каталогах, только если они не содержат изменений.
	При наличии каких-либо изменений со стороны пользователя
	автоматическое обновление таких файлов отменяется.  Есть
	другой параметр <literal>KeepModifiedMetadata</literal>,
	который предписывает команде <command>freebsd-update</command>
	сохранять изменения в процессе слияния.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</programlisting>

      <para>Список каталогов с конфигурационными файлами, для которых
	<command>freebsd-update</command> попытается выполнить
	слияние.  Процесс слияния файла представляет собой
	последовательность изменений в формате &man.diff.1;, похожую
	на &man.mergemaster.8;, но с меньшим количеством параметров.
	Результат слияния принимается, открывается редактор или
	<command>freebsd-update</command> прекращает работу.
	В случае сомнений сделайте резервную копию
	<filename>/etc</filename> и просто согласитесь со всеми
	изменениями.  Для получения подробной информации по команде
	<command>mergemaster</command> смотрите
	<xref linkend="mergemaster"/>.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Этот каталог предназначен для размещения патчей и временных
	файлов.  В случае, когда пользователь выполняет обновление со
	сменой версии, в этом месте нужно иметь по крайней мере гигабайт
	свободного дискового пространства.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Если выставлено значение <literal>yes</literal>, то
	<command>freebsd-update</command> будет исходить из того, что
	список <literal>Components</literal> является полным, и не будет
	пытаться выполнить изменения за пределами этого списка. 
	В действительности <command>freebsd-update</command> попытается
	обновить все файлы, которые принадлежат списку
	<literal>Components</literal>.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Обновления безопасности</title>

      <para>Процесс применения обновлений безопасности &os; был
	упрощён, что позволяет поддерживать систему в актуальном
	состоянии, используя <command>freebsd-update</command>.
	Для получения дополнительной информации по бюллетеням
	безопасности &os; смотрите <xref
	  linkend="security-advisories"/>.</para>

      <para>Обновления безопасности можно загрузить и установить с
	использованием следующих команд.  Первая команда определяет
	наличие незагруженных обновлений и показывает файлы, которые
	будут изменены в процессе обновления.  Вторая команда
	выполняет обновление.</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Если были установлены обновления ядра, то после этого
	нужно перезагрузить систему.  Если обновление установилось
	для какого-либо работающего в системе двоичного файла, то
	следует перезапустить затронутые приложения, чтобы
	использовалась исправленная версия двоичного файла.</para>

      <para>Можно настроить ежедневную автоматическую проверку
	наличия обновлений, добавив следующую запись в
	<filename>/etc/crontab</filename>:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>При наличии обновлений они будут автоматически загружены.
	Пользователю <systemitem class="username">root</systemitem>
	будет отправлено письмо, так что эти обновления можно будет
	просмотреть и установить самостоятельно командой
	<command>freebsd-update install</command>.</para>

      <para>На случай, если что-то пошло не так, в
	<command>freebsd-update</command> предусмотрен механизм возврата
	последнего набора изменений с использованием следующей команды:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput>
Uninstalling updates... done.</screen>

      <para>Если после завершения всех действий было изменено ядро или
	какой-либо из его модулей, система должна быть перезагружена,
	а все затронутые исполняемые файлы нужно перезапустить.</para>

      <para>Команда <command>freebsd-update</command> позволяет
	автоматически обновлять только ядро
	<filename>GENERIC</filename>.  Если используется ядро с
	собственной конфигурацией, его понадобится пересобрать и
	переустановить после того, как
	<command>freebsd-update</command> завершит установку
	обновлений.  Тем не менее, <command>freebsd-update</command>
	обнаружит и обновит ядро <filename>GENERIC</filename> при
	наличии <filename>/boot/GENERIC</filename>, даже если оно не
	является текущим используемым ядром в системе.</para>

      <note>
	<para>Всегда храните копию ядра <filename>GENERIC</filename>
	  в <filename>/boot/GENERIC</filename>.  Оно пригодится при
	  решении различных проблем, а также при выполнении обновления
	  со сменой версии.  Смотрите <xref
	    linkend="freebsd-update-custom-kernel-9x"/> для описания
	  получения копии ядра <filename>GENERIC</filename>.</para>
      </note>

      <para>Если конфигурация в
	<filename>/etc/freebsd-update.conf</filename> не изменялась,
	<command>freebsd-update</command> вместе с остальными
	обновлениями установит обновлённые исходные тексты ядра.
	После этого можно обычным способом выполнить перестроение и
	переустановку нового ядра с собственной конфигурацией.</para>

      <para>Обновления, получаемые с помощью
	<command>freebsd-update</command>, не всегда затрагивают ядро.
	Перестроение собственного ядра не является обязательным, если
	исходные тексты ядра не были изменены при выполнении
	<command>freebsd-update install</command>.  Тем не менее,
	<command>freebsd-update</command> всегда обновляет
	<filename>/usr/src/sys/conf/newvers.sh</filename>.  Текущий
	набор изменений, как указано в номере <literal>-p</literal>
	в выводе <command>uname -r</command>, получается из этого
	файла.  Перестроение собственного ядра, даже если ничего
	больше не менялось, позволяет <command>uname</command>
	правильно сообщать текущий набор изменений в системе.  Это
	в частности может помочь при сопровождении множества систем,
	поскольку позволяет быстро оценить наличие установленных
	обновлений в каждой из них.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Обновления со сменой старшей и младшей версий</title>

      <para>Обновление с &os;&nbsp;9.0 на &os;&nbsp;9.1, называется
	обновлением со сменой младшего номера версии.  Смена старшего
	номера версии происходит, когда &os; переходит с одной
	значительной версии на другую, как, например, при обновлении
	с &os;&nbsp;9.X на &os;&nbsp;10.X.  Оба типа обновлений можно
	произвести, указав <command>freebsd-update</command> версию,
	на которую нужно перейти.</para>

      <note>
	<para>Если в системе используется ядро с собственной
	  конфигурацией, убедитесь перед началом обновления в наличии
	  копии ядра <filename>GENERIC</filename> в
	  <filename>/boot/GENERIC</filename>.  Смотрите <xref
	    linkend="freebsd-update-custom-kernel-9x"/> для описания
	  получения копии ядра <filename>GENERIC</filename>.</para>
      </note>

      <para>Следующая команда, будучи запущенной на &os;&nbsp;9.0,
	выполнит обновление до версии &os;&nbsp;9.1:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

      <para>После своего запуска <command>freebsd-update</command>
	анализирует содержимое конфигурационного файла и собирает
	необходимую для проведения обновления информацию о текущей
	установленной системе.  На экран будет выдан перечень компонентов,
	которые удалось и не удалось обнаружить установленными.
	Например:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? <userinput>y</userinput></screen>

      <para>Следующим шагом <command>freebsd-update</command> попытается
	загрузить по сети файлы, необходимые для выполнения обновления.
	В некоторых случаях может потребоваться ответить на вопросы
	относительно того, что и как устанавливать.</para>

      <para>Если используется ядро с собственной конфигурацией, то
	в этом случае появится предупреждение следующего вида:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>На этом этапе предупреждение можно проигнорировать.
	На промежуточном этапе процесса обновления будет использовано
	обновлённое ядро <filename>GENERIC</filename>.</para>

      <para>После того, как все изменения были загружены, они будут
	применены.  Этот процесс может занять определённое время, в
	зависимости от производительности и текущей загруженности
	компьютера.  Затем будет выполнено слияние конфигурационных
	файлов.  Процесс слияния требует от пользователя определённого
	вмешательства, так как для файла можно выполнить слияние
	автоматически, а можно открыть текстовый редактор для слияния
	вручную.  Результат успешного слияния будет показан на экране.
	Неудачное или пропущенное слияние вызовет преждевременное
	завершение программы.  Можно подготовить резервную копию
	каталога <filename>/etc</filename> для таких важных файлов как
	<filename>master.passwd</filename> и <filename>group</filename> и
	выполнить их слияние вручную позднее.</para>

      <note>
	<para>На данном этапе система еще не модифицирована, и все
	  изменения и слияния происходят в отдельном каталоге.
	  Теперь, когда все изменения успешно применены, все
	  конфигурационные файлы объединены и кажется, что процесс
	  должен пройти плавно, изменения могут быть установлены на
	  диск с помощью следующей команды:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>
      </note>

      <para>В первую очередь изменения будут применены к ядру и его
	модулям.  При использовании ядра с собственной конфигурацией
	укажите для следующей загрузки обновлённое ядро
	<filename>/boot/GENERIC</filename> с помощью
	&man.nextboot.8;:</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Перед перезагрузкой с ядром <filename>GENERIC</filename>
	  убедитесь, что оно содержит все необходимые драйвера для
	  системы для корректной загрузки и подключения к сети, если
	  машина обновляется удалённо.  В частности, если в ядре
	  содержится встроенная функциональность, которая обычно
	  обеспечивается модулями ядра, загрузите эти драйвера с ядром
	  <filename>GENERIC</filename>, временно указав их как модули
	  в <filename>/boot/loader.conf</filename>.  Рекомендуется
	  отключить несущественные службы, а также любые локальные и
	  сетевые диски до завершения процесса обновления.</para>
      </warning>

      <para>Теперь компьютер должен быть перезагружен с новым
	ядром:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>После перезагрузки нужно повторно запустить команду
	<command>freebsd-update</command>.  Команда прочитает, на каком
	этапе она находится, и перейдёт к удалению старых объектных файлов
	и совместно используемых библиотек.</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>Количество этапов установки обновлений может быть два вместо
	  трёх и зависит от того, были ли изменены номера версий каких-либо
	  совместно используемых библиотек.</para>
      </note>

      <para>На этом процесс завершён.  Если было выполнено обновление
	со сменой старшего номера версии, переустановите все порты и
	пакеты в соответствии с описанием, которое предоставляет <xref
	  linkend="freebsdupdate-portsrebuild"/>.</para>

      <sect3 xml:id="freebsd-update-custom-kernel-9x">
	<title>Собственная конфигурация ядра в &os;&nbsp;9.X и более
	  поздних версиях</title>

	<para>Перед использованием <command>freebsd-update</command>
	  убедитесь в наличии копии ядра <filename>GENERIC</filename>
	  в <filename>/boot/GENERIC</filename>.  Если ядро с
	  собственной конфигурацией было собрано единожды, то в
	  <filename>/boot/kernel.old</filename> будет находиться ядро
	  <literal>GENERIC</literal>.  Просто переименуйте этот
	  каталог в <filename>/boot/kernel</filename>.</para>

	<para>Если ядро с собственной конфигурацией было собрано более
	  одного раза, получите копию ядра <literal>GENERIC</literal>,
	  соответствующую текущей версии операционной системы.  При
	  наличии физического доступа копию ядра
	  <literal>GENERIC</literal> можно установить с установочного
	  носителя:</para>

	<screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>

	<para>Иначе, ядро <literal>GENERIC</literal> можно собрать и
	  установить из исходных текстов:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	<para>Чтобы такое ядро было определено как ядро
	  <literal>GENERIC</literal> программой
	  <command>freebsd-update</command>, в файле конфигурации
	  <filename>GENERIC</filename> должны отсутствовать изменения.
	  Также предлагается, что ядро было собрано без использования
	  каких-либо специальных параметров.</para>

	<para>Загрузка с <filename>GENERIC</filename> не требуется,
	  поскольку для <command>freebsd-update</command> достаточно
	  существования <filename>/boot/GENERIC</filename>.</para>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>Обновление пакетов после смены старшей версии
	  системы</title>

	<para>После обновления системы со сменой младшей версии
	  установленные приложения, в целом, продолжают работать без
	  каких-либо проблем.  Различные старшие версии используют
	  различающиеся двоичные интерфейсы приложений (Application
	  Binary Interface, <acronym>ABI</acronym>), из-за чего
	  перестаёт работать большинство сторонних приложений.
	  После обновления системы со сменой старшей версии все
	  установленные пакеты и порты также нуждаются в обновлении.
	  Пакеты можно обновить с использованием <command>pkg
	    upgrade</command>.  Для обновления установленных портов
	  используется <package>ports-mgmt/portmaster</package>.</para>

	<para>Принудительное обновление все установленных пакетов
	  приведёт к их замене на последние версии из репозитория,
	  даже если номер версии при этом не увеличивался.  Это
	  требуется из-за смены версии ABI при обновлении на другую
	  старшую версию &os;.  Принудительное обновление можно
	  выполнить так:</para>

	<screen>&prompt.root; <userinput>pkg-static upgrade -f</userinput></screen>

	<para>Перестроение всех установленных приложений можно
	  выполнить этой командой:</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>Эта команда будет отображать экран выбора конфигурации
	  для каждого приложения, в котором доступны параметры
	  конфигурации, с ожиданием пользовательского ввода.  Чтобы
	  не использовать такое поведение и всегда выбирать параметры
	  по умолчанию, добавьте ключ <option>-G</option> в
	  вышеприведённую команду.</para>

	<para>После завершения процесса обновления программного
	  обеспечения закончите процесс обновления последним запуском
	  <command>freebsd-update</command>, для того чтобы убедиться,
	  что ничто не было пропущено в процессе обновления:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para>Если в качестве временной меры использовалось ядро
	  <filename>GENERIC</filename>, то это подходящее время для
	  построения и установки нового ядра с собственной
	  конфигурацией в соответствии с инструкциями в  <xref
	    linkend="kernelconfig"/>.</para>

	<para>Перезагрузите машину с новой версией &os;.  На этом
	  процесс обновления завершён.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Сравнение состояния системы</title>

      <para>С помощью команды <command>freebsd-update IDS</command>
	можно получить состояние установленной версии &os;
	относительно известной доверенной копии.  Эта команда
	проверяет текущую версию системных утилит, библиотек и
	конфигурационных файлов, и её можно использовать в качестве
	встроенной системы обнаружения вторжений (Intrusion Detection
	System, <acronym>IDS</acronym>).</para>

      <warning>
	<para>Эта команда не является заменой <acronym>IDS</acronym>,
	  такой как <package>security/snort</package>.  Поскольку
	  <command>freebsd-update</command> сохраняет свои данные на
	  диске, возможность подмены становится очевидной.  И хотя эта
	  возможность может быть уменьшена при использовании настройки
	  <varname>kern.securelevel</varname>, а также используя для
	  записи данных <command>freebsd-update</command> файловую
	  систему, которая в остальное время смонтирована только на
	  чтение, лучшим решением будет сравнить систему относительно
	  эталона на физически защищенном носителе, таком как
	  <acronym>DVD</acronym> или внешний <acronym>USB</acronym> диск
	  с включённой защитой от записи.<!--  Альтернативный метод
	  обеспечения функциональности <acronym>IDS</acronym> с
	  использованием встроенных утилит описан в <xref
	    linkend="security-ids"/>.--></para>
      </warning>

      <para>Для того, чтобы начать сравнение, укажите файл для
	сохранения результатов:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <para>Запустится проверка системы, результат которой будет
	записан в указанный файл в виде списка файлов вместе с их
	контрольными суммами в формате <acronym>SHA256</acronym>
	&mdash; для известных файлов из релиза и текущих в
	системе.</para>

      <para>Строки в списке чрезмерно длинные, но зато такой формат
	вывода удобен для разбора.  Так, для получения списка всех
	отличающихся от релиза файлов достаточно выполнить такую
	команду:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Вывод специально обрезан, на самом деле файлов намного больше.
	Некоторые из них изменены в ходе нормальной работы: так, файл
	<filename>/etc/passwd</filename> был изменён после заведения
	пользователей в системе.  Модули ядра могли измениться вследствие
	обновления через <command>freebsd-update</command>.  Для
	исключения из проверки конкретных файлов и каталогов укажите их
	в качестве значения параметра <literal>IDSIgnorePaths</literal>
	в <filename>/etc/freebsd-update.conf</filename>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <title>Обновление документации</title>

    <indexterm>
      <primary>обновление и смена версии</primary>
    </indexterm>

    <indexterm>
      <primary>документация</primary>
      <see>обновление и смена версии</see>
    </indexterm>

    <para>Документация является неотъемлемой частью операционной
      системы &os;.  И хотя актуальная версия документации &os; всегда
      доступна на сайте &os; (<link
	xlink:href="&url.base;/doc/">http://www.freebsd.org/doc/</link>),
      может быть удобно иметь под рукой актуальную локальную копию
      сайта &os;, руководств, <acronym>FAQ</acronym> и статей.</para>

    <para>В этом разделе описывается, как использовать исходный текст
      или Коллекцию Портов &os; для организации актуальной локальной
      копии документации &os;.</para>

    <para>За информацией о редактировании и отправке изменений
      для документации обращайтесь к &os; Documentation Project
      Primer for New Contributors (<link
	  xlink:href="&url.books.fdp-primer;">http://www.freebsd.org/doc/en_US.ISO8859-1/books/fdp-primer/</link>).</para>

    <sect2 xml:id="updating-installed-documentation">
      <title>Обновление документации из исходного кода</title>

      <para>Для перестроения документации &os; из исходного текста
	требуется набор инструментов, который не является частью
	основной системы &os;.  Требуемые инструменты, включая
	<application>svn</application>, можно установить из пакета
	или порта <package>textproc/docproj</package>, разработанного
	в рамках проекта документации &os;.</para>

      <para>После установки используйте <application>svn</application>
	для получения копии исходных текстов документации:</para>

      <screen>&prompt.root; <userinput>svn checkout https://svn.FreeBSD.org/doc/head /usr/doc</userinput></screen>

      <para>Первоначальная загрузка исходных текстов документации
	может занять некоторое время.  Дайте ей завершиться.</para>

      <para>Последующие обновления можно получить, выполнив:</para>

      <screen>&prompt.root; <userinput>svn update /usr/doc</userinput></screen>

      <para>После того как в <filename>/usr/doc</filename> была
	загружена актуальная копия исходных текстов, всё готово
	для обновления установленной документации.</para>

      <para>Полное обновление всех доступных языковых версий можно
	выполнить, набрав команду:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Для обновления только указанной языковой версии команду
	<command>make</command> можно запустить в соответствующем
	подкаталоге <filename>/usr/doc</filename>:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Альтернативный способ обновления документации заключается
	в запуске следующей команды из из <filename>/usr/doc</filename>
	или подкаталога с желаемой языковой версией:</para>

      <screen>&prompt.root; <userinput>make update</userinput></screen>

      <para>Используемый при установке формат можно указать через
	<varname>FORMATS</varname>:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>Для упрощения процесса частичного обновления документации
	и построения только нужных переводов имеется несколько
	параметров.  Их можно задать как на общесистемном уровне,
	указав в <filename>/etc/make.conf</filename>, так и
	непосредственно в команде <command>make</command>.</para>

      <para>Данные параметры включают:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>Перечень языков и кодировок для построения и
	      установки, например,
	      <literal>en_US.ISO8859-1</literal> для англоязычной
	      документации.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>Единый формат или набор форматов для построения.
	      На данный момент поддерживаются <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal> и <literal>pdf</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>Путь для установки документации.  По умолчанию
	      <filename>/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Для получения других переменных <command>make</command>,
	также работающих во &os; в качестве общесистемных, обратитесь
	к &man.make.conf.5;.</para>
    </sect2>

    <sect2 xml:id="doc-ports-install-package">
      <info>
	<title>Обновление документации из портов</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Marc</firstname>
	      <surname>Fonvieille</surname>
	    </personname>
	    <contrib>Основную работу выполнил </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>обновление и смена версии</primary>
      </indexterm>

      <indexterm>
	<primary>пакет документации</primary>
	<see>обновление и смена версии</see>
      </indexterm>

      <para>В предыдущем разделе был представлен метод обновления
	документации &os; из исходных текстов.  В этом разделе
	описывается альтернативный метод с использованием Коллекции
	Портов, который позволяет:</para>

      <itemizedlist>
	<listitem>
	  <para>Установить предварительно собранный пакет документации
	    без необходимости локального построения чего-либо или
	    установки инструментария документации.</para>
	</listitem>

	<listitem>
	  <para>Выполнить построение исходных текстов документации
	    через инфраструктуру портов, что несколько упрощает этапы
	    загрузки и построения.</para>
	</listitem>
      </itemizedlist>

      <para>Данный метод обновления документации &os; предоставляется
	портами и пакетами документации, которые ежемесячно
	обновляет &a.doceng;.  Они перечислены в Коллекции Портов &os;
	в категории docs (<link
	  xlink:href="http://www.freshports.org/docs/">http://www.freshports.org/docs/</link>).</para>

      <para>Порты документации организованы следующим образом:</para>

      <itemizedlist>
	<listitem>
	  <para>Пакет или порт <package>misc/freebsd-doc-en</package>
	    устанавливает всю англоязычную документацию.</para>
	</listitem>

	<listitem>
	  <para>Метапакет или порт
	    <package>misc/freebsd-doc-all</package> устанавливает всю
	    документацию на всех доступных языках.</para>
	</listitem>

	<listitem>
	  <para>Имеются пакеты и порты для каждого перевода, например,
	    <package>misc/freebsd-doc-hu</package> для венгерской
	    документации.</para>
	</listitem>
      </itemizedlist>

      <para>При использовании двоичных пакетов документация &os; будет
	установлена во всех доступных форматах для данного языка.
	Например, следующая команда установит последнюю версию пакета
	венгерской документации:</para>

      <screen>&prompt.root; <userinput>pkg install hu-freebsd-doc</userinput></screen>

      <note>
	<para>Для пакетов используется другая схема наименования,
	  которая отличается от названия соответствующего порта:
	  <literal><replaceable>lang</replaceable>-freebsd-doc</literal>,
	  где <replaceable>lang</replaceable> соответствует
	  сокращённому языковому коду, такому как
	  <literal>hu</literal> для венгерского или
	  <literal>zh_cn</literal> для упрощённого китайского.</para>
      </note>

      <para>Чтобы указать используемый формат документации, для этого
	вместо установки готового пакета нужно собрать порт
	самостоятельно.  Ниже приводится пример построения и установки
	английской документации:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>В порте имеется меню конфигурации, в котором можно указать
	нужный формат.  По умолчанию выбирается
	<acronym>HTML</acronym> с разделителями, такой как на <uri
	  xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri>,
	а также <acronym>PDF</acronym>.</para>

      <para>Иначе, при построении порта документации можно указать
	параметры <command>make</command>, которые включают в
	себя:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>WITH_HTML</varname></term>

	  <listitem>
	    <para>Документ в формате HTML на одной странице.
	      Сформированная документация сохраняется в файле
	      <filename>article.html</filename> или
	      <filename>book.html</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>WITH_PDF</varname></term>

	  <listitem>
	    <para>Сформированная документация сохраняется в файле
	      <filename>article.pdf</filename> или
	      <filename>book.pdf</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCBASE</varname></term>

	  <listitem>
	    <para>Указывает место размещения документации.
	      По умолчанию
	      <filename>/usr/local/share/doc/freebsd</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>В примере ниже демонстрируется использование переменных
	для установки венгерской документации в <acronym>PDF</acronym>
	в указанный каталог:</para>

      <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>

      <para>Пакеты или порты документации обновляются согласно
	инструкциям в <xref linkend="ports"/>.  Например, следующая
	команда выполняет обновление установленной документации на
	венгерском языке с помощью
	<package>ports-mgmt/portmaster</package> в режиме
	использования только готовых пакетов:</para>

      <screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>Использование ветви разработки</title>

    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Во &os; имеется две ветки разработки: &os.current; и
      &os.stable;.</para>

    <para>В этом разделе даётся объяснение для каждой из них и их
      предназначение, а также рассказывается, как синхронизировать
      систему с любой из этих веток.</para>

    <sect2 xml:id="current">
      <title>Использование &os.current;</title>

      <para>&os.current; является <quote>передним краем</quote>
	разработки &os; и предназначена для пользователей с высокой
	технической грамотностью.  Менее продвинутым пользователям,
	также желающим отслеживать ветку разработки, следует
	использовать &os.stable;.</para>

      <para>&os.current; обозначает последнюю версию исходных текстов
	&os; и включает в себя незавершённые работы, экспериментальные
	изменения и переходные механизмы, которые могут отсутствовать
	в следующем официальном релизе.  Хотя многие разработчики
	&os; выполняют компиляцию исходных текстов &os.current;
	ежедневно, бывают периоды, когда исходные тексты могут не
	компилироваться.  Обычно такие проблемы решаются сразу по мере
	возможности, но всё же выбор точки синхронизации исходных
	текстов является определяющим фактором, содержит ли
	&os.current; новую функциональность или же мину замедленного
	действия.</para>

      <para>&os.current; предназначена для трёх основных групп:</para>

      <orderedlist>
	<listitem>
	  <para>Члены сообщества &os;, активно работающие над
	    некоторой частью дерева исходных текстов.</para>
	</listitem>

	<listitem>
	  <para>Члены сообщества &os;, которые являются активными
	    тестерами.  Они тратят свое время на исправление проблем,
	    вносят важные предложения по изменениям и общему развитию
	    &os;, присылают патчи.</para>
	</listitem>

	<listitem>
	  <para>Пользователи, которые хотят быть в курсе изменений,
	    используют текущие исходные тексты для ознакомительных
	    целей либо же иногда высказывают замечания
	    или предоставляют собственный код.</para>
	</listitem>
      </orderedlist>

      <para>&os.current; <emphasis>не</emphasis> должна использоваться
	в качестве быстрого способа получить новые возможности, не
	дожидаясь выпуска следующей версии, поскольку предварительная
	версия не является полностью проверенной и скорее всего
	содержит ошибки.  &os.current; не является быстрым способом
	получения исправлений, поскольку любое изменение является в
	равной мере источником исправления существующих ошибок и
	появления новых.  &os.current; не является <quote>официально
	  поддерживаемой</quote> каким бы то ни было способом.</para>

      <indexterm>
	<primary>-CURRENT</primary>
	<secondary>использование</secondary>
      </indexterm>

      <para>Чтобы отслеживать изменения во &os.current;:</para>

      <orderedlist>
	<listitem>
	  <para>Подпишитесь на списки рассылки &a.current.name; и
	    &a.svn-src-head.name;.  Это
	    <emphasis>необходимо</emphasis> для того, чтобы получать
	    сообщения и важные бюллетени относительно текущего
	    состояния &os.current;.</para>

	  <para>Список рассылки &a.svn-src-head.name; содержит записи
	    из журнала коммитов по каждому изменению, а также
	    сопутствующую информацию о возможных побочных
	    эффектах.</para>

	  <para>Чтобы подписаться на эти списки рассылки, перейдите
	    по ссылке &a.mailman.lists.link;, щёлкните на нужном
	    списке и следуйте дальнейшим инструкциям.  Для того чтобы
	    отслеживать изменения всего дерева исходных текстов, а не
	    только &os.current;, подпишитесь на
	    &a.svn-src-all.name;.</para>
	</listitem>

	<listitem>
	  <para>Загрузите исходные тексты &os.current;.  Обычно для
	    этого используется <link linkend="svn">svn</link>, с
	    помощью которого можно загрузить исходные тексты -CURRENT
	    из ветки <literal>head</literal> с одного из зеркал
	    Subversion, перечисленных в <xref
	      linkend="svn-mirrors"/>.</para>

	  <para>Пользователи с очень медленным или ограниченным
	    подключением могут рассматривать использование CTM,
	    который описывается в <xref linkend="ctm"/>, однако
	    этот способ является менее надёжным по сравнению с
	    рекомендуемым способом синхронизации исходных текстов
	    посредством <application>svn</application>.</para>
	</listitem>

	<listitem>
	  <para>Вследствие больших размеров репозитория некоторые
	    пользователи для ознакомления или изготовления патчей
	    выбирают частичную загрузку.  Тем не менее, для компиляции
	    операционной системы из исходных текстов требуется
	    загрузить &os.current; <emphasis>полностью</emphasis>,
	    а не только лишь выбранные части.</para>

	  <para>Перед началом компиляции &os.current;
	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>компиляция</secondary>
	    </indexterm> внимательно прочтите файл
	    <filename>/usr/src/Makefile</filename> и следуйте
	    инструкциям в <xref linkend="makeworld"/>.  &a.current; и
	    <filename>/usr/src/UPDATING</filename> позволят быть в
	    курсе прочих процедур, которые иногда бывают необходимы в
	    процессе перехода к следующему релизу.</para>
	</listitem>

	<listitem>
	  <para>Будьте активным участником!  Пользователям
	    &os.current; предлагается высказывать свои соображения по
	    улучшению или исправлению ошибок.  Предложения, к которым
	    прилагается код, всегда приветствуются!</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="stable">
      <title>Использование &os.stable;</title>

      <para>&os.stable; является веткой разработки, из которой
	выпускаются основные релизы.  Изменения в этой ветке
	происходят с меньшей скоростью и в предположении, что они
	сперва были проверены во &os.current;.  При этом она
	<emphasis>остаётся</emphasis> веткой разработки, и в любой
	момент времени исходные тексты &os.stable; могут оказаться
	не готовы для обычного использования.  Это просто другая
	ветка разработки, не предназначенная для конечных
	пользователей.  Пользователям, у которых нет возможности
	заниматься тестированием, следует использовать самый
	последний выпуск &os;.</para>

      <para>Тем, кто заинтересован процессом разработки &os; или
	желает поучаствовать, особенно поскольку от этого зависит
	следующий релиз &os;, стоит отслеживать &os.stable;.</para>

      <para>Хотя ветка &os.stable; должна всегда компилироваться и
	работать, это невозможно гарантировать.  Поскольку гораздо
	больше людей работает с &os.stable;, неудивительно, что в
	&os.stable; иногда обнаруживаются ошибки и всплывают
	непредвиденные ситуации, которые не проявляли себя в
	&os.current;.  По этим причинам не рекомендуется слепо
	использовать &os.stable;.  Особенно важно
	<emphasis>не</emphasis> обновлять какие-либо сервера,
	находящиеся в эксплуатации, до &os.stable; без тщательного
	тестирования кода в среде разработки.</para>

      <para>Чтобы отслеживать изменения во &os.stable;:</para>

      <indexterm>
	<primary>-STABLE</primary>
	  <secondary>использование</secondary>
      </indexterm>
      <orderedlist>
	<listitem>
	  <para>Подпишитесь на список рассылки &a.stable.name;, чтобы
	    быть в курсе о зависимостях процесса компиляции, которые
	    могут появиться во &os.stable; или любых других проблемах,
	    требующих особого внимания.  Также в этом списке рассылки
	    разработчики делают объявления о спорных исправлениях или
	    добавлениях, давая пользователям возможность высказать
	    свое мнение о возможных тонких моментах.</para>

	  <para>Подпишитесь на список рассылки
	    <application>svn</application>, соответствующий
	    используемой ветви.  Например, при использовании 9-STABLE
	    следует подписаться на &a.svn-src-stable-9.name;.  Этот
	    список рассылки содержит записи из журнала коммитов по
	    каждому изменению, а также сопутствующую информацию о
	    возможных побочных эффектах.</para>

	  <para>Чтобы подписаться на эти списки рассылки, перейдите
	    по ссылке &a.mailman.lists.link;, щёлкните на нужном
	    списке, и следуйте дальнейшим инструкциям.  Для того чтобы
	    отслеживать изменения всего дерева исходных текстов,
	    подпишитесь на &a.svn-src-all.name;.</para>
	</listitem>

	<listitem>
	  <para>Чтобы установить новую систему &os.stable;, установите
	    самый последний релиз &os.stable;, загрузив его с <link
	      linkend="mirrors">зеркалирующих сайтов &os;</link> или
	    используйте ежемесячную стандартную сборку &os.stable;.
	    Обратитесь к <link
	      xlink:href="&url.base;/snapshots/">www.freebsd.org/snapshots</link>
	    для получения дополнительной информации о снэпшотах.</para>

	  <para>Чтобы скомпилировать новую или обновить существующую
	    систему &os; до &os.stable;, используйте
	    <link linkend="svn">svn</link>
	      <indexterm>
		<primary>Subversion</primary>
	      </indexterm> для загрузки исходных текстов нужной ветки.
	    Имена веток вида <literal>stable/9</literal> перечислены
	    на странице <link
	      xlink:href="&url.base;/releng/">www.freebsd.org/releng</link>.
	    При отсутствии надёжного Интернет-соединения можно
	    воспользоваться CTM (<xref linkend="ctm"/>).</para>
	</listitem>

	<listitem>
	  <para>Перед началом компиляции или обновления до &os.stable;
	    <indexterm>
	      <primary>-STABLE</primary>
	      <secondary>компиляция</secondary>
	    </indexterm> внимательно прочтите файл
	    <filename>/usr/src/Makefile</filename> и следуйте
	    инструкциям в <xref linkend="makeworld"/>.  &a.stable; и
	    <filename>/usr/src/UPDATING</filename> позволят быть в
	    курсе прочих процедур, которые иногда бывают необходимы
	    в процессе перехода к следующему релизу.</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>Синхронизация исходных текстов</title>

    <para>Имеются различные способы синхронизации с исходными
      текстами &os;.  В этом разделе сравниваются основные из них,
      <application>Subversion</application> и
      <application>CTM</application>.</para>

    <warning>
      <para>Хотя возможно частичное обновление дерева исходных
	текстов, единственной поддерживаемой процедурой обновления
	является обновление всего дерева и перекомпиляция всех
	программ, работающих в контексте пользователя, например тех,
	что находятся в каталогах <filename>/bin</filename> и
	<filename>/sbin</filename>, а также исходных текстов ядра.
	Обновление только части дерева исходных текстов, только ядра
	или только программ часто приводит к возникновению проблем от
	ошибок компиляции до аварийных остановов системы или потери
	данных.</para>
    </warning>

    <indexterm>
      <primary>Subversion</primary>
    </indexterm>

    <para><application>Subversion</application> для обновления
      исходных текстов использует модель <emphasis>pull</emphasis>.
      Пользователь или сценарий <command>cron</command> запускают
      программу <command>svn</command>, которая обновляет локальную
      версию исходных текстов.  <application>Subversion</application>
      является предпочтительным способом обновления локального дерева
      исходных текстов, поскольку обновления являются актуальными с
      точностью до минуты и пользователь управляет временем их
      загрузки.  Загрузку определённых файлов и каталогов легко
      ограничить, а запрашиваемые обновления формируются на лету на
      стороне сервера.  О том, как актуализировать исходные тексты с
      использованием <application>Subversion</application>, описано в
      <xref linkend="svn"/>.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application> не выполняет интерактивное
      сравнение имеющихся исходных текстов с находящимися в главном
      архиве, и не выполняет их загрузку.
      Вместо этого несколько раз в день на главной машине CTM
      запускается скрипт, находящий изменения в файлах с момента
      своего предыдущего запуска.  Все обнаруженные изменения сжимаются,
      помечаются последовательным номером и кодируются для передачи по
      электронной почте в печатном формате <acronym>ASCII</acronym>.
      После получения эти <quote>дельта-файлы CTM</quote> могут быть
      переданы утилите <command>ctm.rmail</command>, которая
      осуществляет автоматическое декодирование, проверку и применение
      изменений к пользовательской копии исходных текстов.  Этот
      процесс более эффективен по сравнению с используемым в
      <application>Subversion</application> и требует меньше ресурсов
      сервера, так как он выполнен по модели <emphasis>push</emphasis>,
      а не <emphasis>pull</emphasis>.  Инструкции по использованию
      <application>CTM</application> для синхронизации исходных
      текстов даны в <xref linkend="ctm"/>.</para>

    <para>Если пользователь случайно уничтожил часть своего архива,
      <application>Subversion</application> обнаружит и перестроит
      повреждённую часть.  <application>CTM</application> этого
      не делает, поэтому если пользователь удалил часть дерева
      исходных текстов и не имеет архивной копии, то нужно будет
      начать с самого начала (с последнего <quote>базового
      дельта-файла</quote>), перестроив всё с помощью
      <application>CTM</application>.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>Пересборка мира</title>

    <indexterm>
      <primary>Пересборка <quote>world</quote></primary>
    </indexterm>
    <para>После того, как локальное дерево исходных текстов было
      синхронизировано с некоторой версией &os; (&os.stable; или
      &os.current;), его можно использовать для перестроения системы.
      Этот процесс известен как перестроение мира.</para>

    <para><emphasis>Перед</emphasis> перестроением мира убедитесь в
      выполнении следующих действий:</para>

    <procedure>
      <title><emphasis>Перед</emphasis> тем как приступать к
	построению мира</title>

      <step>
	<para>Сохраните резервную копию всех важных данных на другую
	  систему или съёмный носитель, проверьте её целостность и
	  держите под рукой загрузочный носитель.  Невозможно
	  переоценить важность создания резервной копии системы
	  <emphasis>до</emphasis> начала перестроения системы.  Хотя
	  перестроение системы является простой задачей, неизбежно
	  возникают ситуации, при которых ошибки в исходных текстах
	  приводят к тому, что система перестаёт загружаться.
	  Возможно, вам никогда не придётся этим воспользоваться, но,
	  постучав по дереву, всегда лучше подстраховаться.</para>
      </step>

      <step>
	<indexterm><primary>список рассылки</primary></indexterm>
	<para>Проверьте последние сообщения в списке рассылки
	  &a.stable.name; или &a.current.name; (в зависимости от
	  отслеживаемой ветки).  Будьте в курсе любых известных
	  проблем, и тех систем, которые они затрагивают.  В случае
	  возникновения подобной проблемы, дождитесь сообщения о
	  том, что эта проблема решена.  После этого повторите
	  синхронизацию исходных текстов для получения необходимого
	  исправления.</para>
      </step>

      <step>
	<para>Прочтите <filename>/usr/src/UPDATING</filename> для
	  получения информации о дополнительных шагах, необходимых для
	  данной версии исходных текстов.  В этом файле содержится
	  важная информация о возможных проблемах и может быть указан
	  порядок выполнения соответствующих команд.  При большинстве
	  обновлений требуются дополнительные шаги, например,
	  переименование или удаление определённых файлов перед
	  установкой нового мира.  Эти шаги будут перечислены в конце
	  файла, где в явном виде описывается текущая рекомендуемая
	  последовательность действий при обновлении.  Если содержимое
	  <filename>UPDATING</filename> противоречит каким-либо шагам
	  в этой главе, руководствуйтесь инструкциями в файле
	  <filename>UPDATING</filename>, которые имеют больший
	  приоритет.</para>
      </step>
    </procedure>

    <warning>
      <title>Не используйте <command>make world</command></title>

      <para>В некоторой устаревшей документации рекомендуется
	использование <command>make world</command>.  Эта команда
	пропускает некоторые важные шаги, поэтому использовать её
	следует лишь в том случае, если вы точно знаете, что делаете.
	Почти во всех случаях <command>make world</command> &mdash;
	это неправильный способ, вместо этого следует использовать
	описанную здесь процедуру.</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>Обзор процесса</title>

      <para>Процесс построения мира подразумевает переход с более
	старой версии &os; с использованием исходных текстов более
	новой версии, которые были получены согласно инструкциям в
	<xref linkend="synching"/>.</para>

      <para>Во &os; термин <quote>world</quote> обозначает ядро,
	исполняемые файлы основой системы, библиотеки, файлы для
	программирования и встроенный компилятор.  Имеет значение
	порядок, при котором эти компоненты собираются и
	устанавливаются.</para>

      <para>Например, из-за ошибки в старом компиляторе невозможно
	было бы скомпилировать новое ядре.  Поскольку новое ядро
	должно быть собрано новым компилятором, для этого в свою
	очередь необходимо собрать новый компилятор, но устанавливать
	его перед сборкой ядра необязательно.</para>

      <para>Новый мир может зависеть от особенностей нового ядра,
	поэтому новое ядро должно быть установлено до установки нового
	мира.  Старый мир может работать неправильно на новом ядре,
	поэтому новый мир должен быть установлен сразу после установки
	нового ядра.</para>

      <para>Перед установкой нового мира могут потребоваться изменения
	в конфигурации, но некоторые из изменений могут не работать
	со старым миром.  Следовательно, используются два разных этапа
	обновления конфигурации.  В основной части процесса обновления
	выполняется только замена или добавление файлов.  Существующие
	файлы при этом не удаляются.  Поскольку это может повлечь
	проблемы, в <filename>/usr/src/UPDATING</filename> содержится
	информация о том, какие из файлов и на каком шаге нужно
	удалить вручную.</para>

      <para>Исходя из этих соображений в следующей процедуре описана
	рекомендуемая последовательность обновления.</para>

      <note>
	<para>Хорошей практикой является запись в файл вывода команды
	  <command>make</command>.  Если что-то пошло не так, копию
	  сообщения об ошибке можно отправить в один из списков
	  рассылки &os;.</para>

	<para>Проще всего использовать для этого
	  <command>script</command> с параметром, задающим имя файла
	  для сохранения всего вывода.  Не сохраняйте вывод в
	  <filename>/tmp</filename>, так как этот каталог может быть
	  очищен при следующей перезагрузке.  Более подходящим местом
	  является <filename>/var/tmp</filename>.  Запустите команду
	  непосредственно перед перестроением мира, а после завершения
	  процесса наберите <userinput>exit</userinput>:</para>

	<screen>&prompt.root; <userinput>script <replaceable>/var/tmp/mw.out</replaceable></userinput>
Script started, output file is /var/tmp/mw.out</screen>
      </note>

      <procedure>
	<title>Обзор процесса построения мира</title>

	<para>Команды для построения мира должны запускаться в
	  указанном здесь порядке.  В этом разделе даётся краткое
	  описание назначения каждой из команд.</para>

	<step>
	  <para>Если процесс построения мира уже запускался ранее на
	    этой системе, то в <filename>/usr/obj</filename> могла
	    остаться копия предыдущей сборки.  Удалите этот каталог
	    для ускорения процесса построения нового мира и возможного
	    сокращений работы по разрешению зависимостей.</para>

	  <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/*</userinput>
&prompt.root; <userinput>rm -rf /usr/obj</userinput></screen>
	</step>

	<step>
	  <para>Скомпилируйте новый компилятор и несколько
	    сопутствующих инструментов и используйте их для
	    компиляции остальной части мира.  Результаты сохраняются
	    в <filename>/usr/obj</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput></screen>
	</step>

	<step>
	  <para>Для построения нового ядра используйте компилятор,
	    расположенный в <filename>/usr/obj</filename>, чтобы
	    защититься от ошибок несоответствия между компилятором и
	    ядром.  Это необходимо, так как определённые структуры
	    данных могут поменяться, и при использовании различных
	    версий ядра и исходных текстов перестанут работать
	    <command>ps</command> и <command>top</command>.</para>

	  <screen>&prompt.root; <userinput>make buildkernel</userinput></screen>
	</step>

	<step>
	  <para>Установите новое ядро и модули, чтобы их можно было
	    использовать для загрузки.  Если используется
	    <varname>kern.securelevel</varname> со значением выше
	    <literal>1</literal> <emphasis>и</emphasis> на файле ядра
	    установлен <literal>noschg</literal> или подобный флаг,
	    то для этого сперва придётся дополнительно перейти в
	    однопользовательский режим.  В противном случае эту
	    команду можно без проблем запустить в
	    многопользовательском режиме.  Смотрите страницу
	    Справочника &man.init.8; для получения информации о
	    <varname>kern.securelevel</varname>, а также
	    &man.chflags.1; для информации об использовании различных
	    файловых флагов.</para>

	  <screen>&prompt.root; <userinput>make installkernel</userinput></screen>
	</step>

	<step>
	  <para>Переведите систему в однопользовательский режим
	    для минимизации проблем при обновлении уже работающих
	    исполняемых файлов.  Это также уменьшит вероятность
	    возникновения проблем при работе старого мира на новом
	    ядре.</para>

	  <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

	  <para>После перехода в однопользовательский режим, запустите
	    эти команды, если в системе используется UFS:</para>

	  <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

	  <para>Если используется ZFS, запустите другие две команды.
	    В данном примере zpool называется
	    <literal>zroot</literal>:</para>

	  <screen>&prompt.root; <userinput>zfs set readonly=off zroot</userinput>
&prompt.root; <userinput>zfs mount -a</userinput></screen>
	</step>

	<step>
	  <para>Дополнительно: Если желаемая картография клавиатуры
	    отличается от используемой по умолчанию US English, её
	    можно изменить с помощью &man.kbdmap.1;:</para>

	  <screen>&prompt.root; <userinput>kbdmap</userinput></screen>
	</step>

	<step>
	  <para>Затем, если часы <acronym>CMOS</acronym> установлены
	    на местное время (это так, если вывод &man.date.1; не
	    содержит правильное время и часовой пояс),
	    выполните:</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>
	</step>

	<step>
	  <para>Пересборка мира не включает в себя добавление или
	    обновление конфигурационных файлов в
	    <filename>/etc</filename>, <filename>/var</filename>,
	    <filename>/usr</filename> и некоторых других каталогах.
	    Следующим шагом является выполнение первоначального
	    обновления файлов конфигурации в <filename>/etc</filename>
	    для подготовки к новому миру.  Следующая команда
	    ограничивается сравнением файлов, необходимых для успешного
	    выполнения цели <buildtarget>installworld</buildtarget>.
	    В частности, на этом шаге могут быть добавлены новые
	    пользовательские группы, служебные учётные записи и
	    сценарии автозапуска, которые были добавлены во &os; со
	    времени последнего обновления.  Это необходимо для их
	    использования при выполнении шага
	    <buildtarget>installworld</buildtarget>.  Смотрите <xref
	      linkend="mergemaster"/> для получения более подробных
	    инструкций по этой команде:</para>

	  <screen>&prompt.root; <userinput>mergemaster -p</userinput></screen>
	</step>

	<step>
	  <para>Установите новый мир и служебные исполняемые файлы,
	    находящиеся в <filename>/usr/obj</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>
	</step>

	<step>
	  <para>Обновите остальные файлы конфигурации.</para>

	  <screen>&prompt.root; <userinput>mergemaster -iF</userinput></screen>
	</step>

	<step>
	  <para>Удалите устаревшие файлы.  Это важно, так как в
	    противном случае они могут вызвать проблемы.</para>

	  <screen>&prompt.root; <userinput>make delete-old</userinput></screen>
	</step>

	<step>
	  <para>Теперь нужна полная перезагрузка системы для того,
	    чтобы загрузить новое ядро и мир с использованием новых
	    конфигурационных файлов.</para>

	  <screen>&prompt.root; <userinput>reboot</userinput></screen>
	</step>

	<step>
	  <para>Убедитесь, что перед удалением старых версий библиотек
	    все установленные порты были пересобраны согласно
	    инструкциям в <xref linkend="ports-upgrading"/>.  По
	    завершению удалите все старые библиотеки во избежание
	    конфликтов с их новыми версиями.  За подробным описанием
	    этого шага обратитесь к <xref
	      linkend="make-delete-old"/>.</para>

	  <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
	</step>
      </procedure>

      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Если для системы доступно окно обслуживания, обдумайте
	возможность компиляции системы в однопользовательском режиме
	вместо использования для этого многопользовательского режима
	с переводом в однопользовательский режим для установки.
	Переустановка системы затрагивает множество важных системных
	файлов, все стандартные системные исполняемые файлы,
	библиотеки и заголовочные файлы.  Замена этих файлов на
	работающей системе (в частности, используемых в данный момент
	пользователями) может привести к неприятностям.</para>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>Файлы конфигурации</title>

      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>В процессе построения мира используется несколько файлов
	конфигурации.</para>

      <para><filename>Makefile</filename>, расположенный в
	<filename>/usr/src</filename>, описывает правила и порядок
	построения программ, составляющих &os;.</para>

      <para>В &man.make.conf.5; описаны параметры, доступные для
	<command>make</command>, а также несколько общих примеров
	имеется в
	<filename>/usr/share/examples/etc/make.conf</filename>.
	Добавляемые в <filename>/etc/make.conf</filename> параметры
	определяют поведение <command>make</command> при построении
	программ.  Эти параметры действуют при каждом использовании
	<command>make</command>, включая компиляцию приложений из
	Коллекции Портов, компиляцию собственных программ на Си и
	построение операционной системы &os;.  Изменение некоторых
	настроек может иметь далекоидущие и порой неожиданные
	последствия.  Прочтите комментарии в обоих местах и примите
	к сведению, что значения по умолчанию были выбраны как
	компромисс между производительностью и надёжностью.</para>

      <indexterm>
	<primary><filename>src.conf</filename></primary>
      </indexterm>

      <para>Поведение при сборке операционной системы из исходных
	текстов задаётся в <filename>/etc/src.conf</filename>.  В
	отличие от <filename>/etc/make.conf</filename>, содержимое
	<filename>/etc/src.conf</filename> влияет только на сборку
	самой операционной системы &os;.  Описание многих параметров,
	доступных в этом файле, имеется в &man.src.conf.5;.  Будьте
	осторожны при выключении на первый взгляд ненужных модулей
	ядра или параметров сборки.  Иногда между ними имеются
	неожиданные или неочевидные взаимозависимости.</para>
    </sect2>

    <sect2 xml:id="make-buildworld">
      <title>Переменные и цели выполнения</title>

      <para>Общий формат использования <command>make</command>:</para>

      <screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

      <para>В этом примере параметр
	<option>-<replaceable>x</replaceable></option> передаётся
	<command>make</command>.  Обратитесь к странице Справочника
	&man.make.1; для получения примеров использования имеющихся
	параметров.</para>

      <para>Чтобы передать переменную, укажите её имя с использованием
	<option>-D<replaceable>VARIABLE</replaceable></option>.
	Поведение <filename>Makefile</filename> зависит от переменных.
	Они могут быть заданы в <filename>/etc/make.conf</filename>
	или указаны при использовании <command>make</command>.
	Например, эта переменная указывает, что библиотеки для
	профилирования собирать не нужно:</para>

      <screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

      <para>Это соответствует настройке в
	<filename>/etc/make.conf</filename>:</para>

      <programlisting>NO_PROFILE=    true     #    Обход построения библиотек для профилирования</programlisting>

      <para><replaceable>target</replaceable> указывает программе
	<command>make</command> на то, что нужно сделать, а
	<filename>Makefile</filename> определяет доступные цели.
	Некоторые цели используются в процессе построения для
	разбиения его на этапы.</para>

      <para>Разделение опций удобно по двум причинам.  Во-первых, это
	позволяет выполнять сборку, не затрагивая компоненты рабочей
	системы.  По этой причине можно спокойно запустить
	<buildtarget>buildworld</buildtarget> на машине, работающей в
	многопользовательском режиме.  Но цель
	<buildtarget>installworld</buildtarget> всё же рекомендуется
	запускать в однопользовательском режиме.</para>

      <para>Во-вторых, это позволяет использовать монтирование по
	<acronym>NFS</acronym> для обновления многих машин по сети
	согласно описанию в <xref linkend="small-lan"/>.</para>

      <para>Параметр <option>-j</option> приводит к запуску нескольких
	одновременно работающих процессов <command>make</command>.
	Поскольку процесс компиляции больше всего требователен к
	подсистеме ввода/вывода, а не к производительности процессора,
	это можно использовать и на машинах с одним процессором.</para>

      <para>Используйте следующую команду на машине с одним CPU,
	чтобы иметь до 4 одновременно работающих процессов.
	Опубликованные в списке рассылки практические замеры
	показывают, что в среднем это даёт наибольший выигрыш в
	производительности.</para>

      <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

      <para>На многопроцессорной машине попробуйте подобрать значение
	между <literal>6</literal> и <literal>10</literal>, и
	посмотрите, как это отразится на скорости работы.</para>

      <indexterm>
	<primary>перестроение <quote>мира</quote></primary>
	<secondary>тайминги</secondary>
      </indexterm>

      <note>
	<para>Если при выполнении команды <command>make
	    buildworld</command> были заданы значения каких-либо
	  переменных, то при выполнении <command>make
	    installworld</command> нужно задать те же самые переменные.
	  При этом <option>-j</option> <emphasis>нельзя</emphasis>
	  использовать совместно с
	  <buildtarget>installworld</buildtarget>.</para>

	<para>Например, если выполнялась эта команда:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>то результат её выполнения должен устанавливаться
	  командой:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>В противном случае вторая команда попытается установить
	  библиотеки для профилирования, которые не компилировались на
	  этапе выполнения команды <command>make
	    buildworld</command>.</para>
      </note>
    </sect2>

    <sect2 xml:id="mergemaster">
      <info>
      <title>Объединение файлов конфигурации</title>

	  <authorgroup>
	    <author>
	      <personname>
		<firstname>Tom</firstname>
		<surname>Rhodes</surname>
	      </personname>
	      <contrib>Текст предоставил </contrib>
	    </author>
	  </authorgroup>
	</info>

	<indexterm>
	  <primary>
	    <command>mergemaster</command>
	  </primary>
	</indexterm>

      <para>&os; предоставляет утилиту &man.mergemaster.8;, которая
	является скриптом для оболочки Боурна и предназначена для
	определения разницы между конфигурационными файлами в каталоге
	<filename>/etc</filename> и конфигурационными файлами из
	дерева исходных текстов <filename>/usr/src/etc</filename>.
	Это является рекомендуемым способом синхронизации системных
	конфигурационных файлов с теми, что размещены в дереве
	исходных текстов.</para>

      <para>Перед использованием <command>mergemaster</command>
	рекомендуется скопировать имеющийся каталог
	<filename>/etc</filename> в какое-нибудь безопасное место.
	<option>-R</option> задает выполнение рекурсивного копирования,
	а <option>-p</option> сохраняет даты и владельца файлов:</para>

      <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

      <para>При запуске <command>mergemaster</command> строит
	временное корневое окружение, начиная с
	<filename>/</filename>, и заполняет его различными системными
	конфигурационными файлами.  Затем эти файлы сравниваются с
	текущими установленными в системе.  Файлы, которые имеют
	отличия, будут выданы в формате &man.diff.1;, где знак
	<option>+</option> означает добавленные или изменённые строки,
	а знак <option>-</option> означает строки, которые будут либо
	полностью удалены, либо заменены на новый файл.  Обратитесь к
	страницам справочной системы по команде &man.diff.1; для
	получения более полной информации о формате выдачи отличий в
	файлах.</para>

      <para>Затем <command>mergemaster</command> выдаст каждый файл, в
	котором есть изменения, с вариантами действий: удалить новый
	файл, упоминаемый здесь как временный, установить временный
	файл в его неизменённом виде, объединить временный файл с
	установленным на данный момент, либо просмотреть результат ещё
	раз.</para>

      <para>Выбор удаления временного файла укажет
	<command>mergemaster</command> оставить текущий файл без
	изменений и удалить его новую версию.  Делать это не
	рекомендуется.  Чтобы получить помощь в любое время, наберите
	<keycap>?</keycap> в приглашении <command>mergemaster</command>.
	Если пользователь выбирает пропуск файла, запрос появится
	снова, после того как будут обработаны все остальные
	файлы.</para>

      <para>Выбор установки немодифицированного временного файла
	приведёт к замене текущего файла новым.  Для большинства
	немодифицированных файлов это является подходящим
	вариантом.</para>

      <para>Выбор варианта с объединением файла приведёт к вызову
	текстового редактора, содержащего текст обоих файлов.  Файлы
	можно объединить, просматривая оба файла на экране и выбирая
	те части из обоих, которые подходят для окончательного
	варианта.  При сравнении файлов нажатие <keycap>l</keycap>
	выбирает содержимое слева, нажатие <keycap>r</keycap> выбирает
	содержимое справа.  В окончательном варианте будет файл,
	состоящий из обеих частей, который и будет установлен.  Этот
	вариант обычно используется для файлов, настройки в которых
	изменялись пользователем.</para>

      <para>Выбор повторного просмотра результатов выдаст разницу
	между файлами.</para>

      <para>После того как утилита <command>mergemaster</command>
	закончит работу с системными файлами, она выдаст запрос
	относительно других параметров.  Она может запросить
	перестроение файла паролей и завершится запросом на удаление
	оставшихся временных файлов.</para>
    </sect2>

    <sect2 xml:id="make-delete-old">
      <info>
	<title>Удаление устаревших файлов и библиотек</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Anton</firstname>
	      <surname>Shterenlikht</surname>
	    </personname>
	    <contrib>На основе заметок, которые предоставил </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>Удаление устаревших файлов и каталогов</primary>
      </indexterm>

      <para>В ходе жизненного цикла разработки &os; файлы с их
	содержимым иногда становятся устаревшими.  Это может быть
	вызвано тем, что функциональность реализуется в другом месте,
	сменился номер версии библиотеки или файл был целиком удалён
	из системы.  Такие устаревшие файлы, библиотеки и каталоги
	следует удалять вместе с обновлением системы.  Это не даст
	захламить систему старыми файлами, которые занимают место на
	диске и на архивных носителях.  Кроме того, если в старой
	библиотеке имеется проблема безопасности или стабильности,
	такую систему следует обновить до более новой библиотеки,
	чтобы предотвратить крахи, вызванные работой старой версии.
	Файлы, каталоги и библиотеки, которые признаны устаревшими,
	перечислены в <filename>/usr/src/ObsoleteFiles.inc</filename>.
	Для удаления устаревших файлов в процессе обновления системы
	следует пользоваться следующими инструкциями.</para>

      <para>После выполнения <command>make installworld</command>
	и последующего <command>mergemaster</command> проверьте
	наличие устаревших файлов и библиотек:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

      <para>Если были найдены какие-либо устаревшие файлы, их можно
	удалить с помощью следующей команды:</para>

      <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

      <para>Перед удалением каждого устаревшего файла запрашивается
	подтверждение.  Используйте
	<varname>BATCH_DELETE_OLD_FILES</varname>, чтобы сократить
	этот процесс и позволить системе удалить эти файлы
	автоматически:</para>

      <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

      <para>Аналогичного эффекта можно достичь, пропустив эти команды
	через <command>yes</command>:</para>

      <screen>&prompt.root; <userinput>yes|make delete-old</userinput></screen>

      <warning>
	<title>Предупреждение</title>

	<para>Удаление устаревших файлов приведёт к нарушению работы
	  программ, которые всё ещё зависят от этих устаревших файлов.
	  Это особенно верно для старых библиотек.  В большинстве
	  случаев программы, порты или библиотеки, использующие такую
	  старую библиотеку, нужно перекомпилировать перед выполнением
	  <command>make delete-old-libs</command>.</para>
      </warning>

      <para>Программы для проверки наличия зависимостей от совместно
	используемых библиотек включают в себя
	<package>sysutils/libchk</package> и
	<package>sysutils/bsdadminscripts</package>.</para>

      <para>Устаревшие совместно используемые библиотеки могут
	конфликтовать с более новыми библиотеками, что приводит к
	сообщениям следующего вида:</para>

      <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

      <para>Для решения этих проблем выясните, какой именно порт
	установил данную библиотеку:</para>

      <screen>&prompt.root; <userinput>pkg which /usr/local/lib/libtiff.so</userinput>
  /usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg which /usr/local/lib/libXext.so</userinput>
  /usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

      <para>Затем данный порт нужно удалить, пересобрать и
	переустановить.  Для автоматизации этого процесса можно
	использовать <package>ports-mgmt/portmaster</package>.  После
	того как все порты пересобраны и более не используют старые
	библиотеки, удалите эти старые библиотеки с помощью следующей
	команды:</para>

      <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>

      <para>Если что-то работает неправильно, можно с лёгкостью
	перестроить конкретную часть системы.  Например, если файл
	<filename>/etc/magic</filename> был случайно удалён в процессе
	обновления или переноса <filename>/etc</filename>, то команда
	<command>file</command> перестанет работать.  	В таком случае
	это можно исправить вот так:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>Вопросы общего характера</title>

      <variablelist>
	<varlistentry>
	  <term>Нужно ли полностью перестраивать систему при каждом
	    изменении?</term>

	  <listitem>
	    <para>Это зависит от характера изменения.  Например, если
	      <application>svn</application> показывает, что с момента
	      последнего запуска были изменены только следующие
	      файлы:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>то перестраивать всю систему возможно незачем.
	      Вместо этого можно перейти в соответствующие подкаталоги
	      и выдать команду <command>make all install</command>.
	      Однако если меняется что-то важное, например,
	      <filename>src/lib/libc/stdlib</filename>, то вы должны
	      перестроить всю систему.</para>

	    <para>Некоторые пользователи перестраивают систему каждые
	      две недели, позволяя изменениям накопиться за это время.
	      Другие перестраивают только те вещи, которые менялись,
	      и внимательно отслеживают все зависимости.  Всё это
	      зависит от того, как часто пользователь хочет делать
	      обновление и отслеживает ли он &os.stable; или
	      &os.current;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Почему прерывается компиляция с большим
	    количеством ошибок по сигналу 11<indexterm>
	      <primary>сигнал 11</primary>
	    </indexterm>
	    (или с другим номером сигнала)?</term>

	  <listitem>
	    <para>Как правило, это говорит о проблемах с оборудованием.
	      Построение системы является эффективным стресс-тестом для
	      оборудования, в особенности памяти.  Явным указателем на
	      это является то, что при перезапуске
	      <application>make</application> процедура построения
	      прекращается в различные моменты времени.</para>

	    <para>Для исправления этой ошибки попробуйте заменить
	      комплектующие машины, начиная с оперативной памяти,
	      для определения сбоящей компоненты.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Можно ли удалить <filename>/usr/obj</filename>
	      после окончания?</term>

	  <listitem>
	    <para>В этом каталоге содержатся все объектные файлы,
	      которые создаются во время фазы компиляции.  Обычно
	      одним из первых шагов в процессе <command>make
		buildworld</command> является удаление этого каталога,
	      чтобы начать заново.  Сохранение
	      <filename>/usr/obj</filename> после окончания имеет мало
	      смысла, а его удаление освободит приблизительно 2 ГБ
	      дискового пространства.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Могут ли быть продолжены прерванные процессы
	    построения?</term>

	  <listitem>
	    <para>Это зависит от того, насколько далеко зашел процесс
	      построения перед тем, как была обнаружена проблема.
	      В общем случае процесс <command>make
		buildworld</command> строит новые копии необходимых
	      инструментальных средств и системные библиотеки.  Затем
	      эти средства и библиотеки устанавливаются.  Новые
	      инструментальные средства и библиотеки затем используются
	      для перестроения самих себя и повторно устанавливаются.
	      Система в целом теперь перестраивается с новыми
	      системными файлами.</para>

	    <para>На последней стадии выполнение этих команд является
	      достаточно безопасным, поскольку они не отменяют работу
	      предыдущего <command>make buildworld</command>:</para>

	    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Если в выводе <command>make buildworld</command>
	      появляется такое сообщение:</para>

	    <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>то делать так вероятно достаточно безопасно.</para>

	    <para>Если такое сообщение не выводится, всегда лучше
	      подстраховаться и запустить сборку с самого начала.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Можно ли ускорить сборку мира?</term>

	  <listitem>
	    <para>Ускорить процесс сборки мира может несколько
	      действий.  Например, весь процесс можно выполнять в
	      однопользовательском режиме.  Однако, это не позволит
	      пользователям иметь доступ к системе, пока этот процесс
	      не завершится.</para>

	    <para>Тщательный подход к проектированию файловой системы
	      или использование датасетов ZFS позволит почувствовать
	      разницу.  Задумайтесь о размещении
	      <filename>/usr/src</filename> и
	      <filename>/usr/obj</filename> на различных файловых
	      системах.  По возможности размещайте файловые системы
	      на различных дисках и дисковых контроллерах.  При
	      монтировании <filename>/usr/src</filename> используйте
	      параметр <option>noatime</option>, который отключает
	      запись информации о времени доступа к файлу.  Если
	      <filename>/usr/src</filename> не расположен на
	      собственной файловой системе, подумайте о
	      перемонтировании <filename>/usr</filename> с
	      <option>noatime</option>.</para>

	    <para>Файловая система, на которой располагается
	      <filename>/usr/obj</filename>, может быть смонтирована
	      (или перемонтирована) с параметром <option>async</option>.
	      Это приведёт к тому, что операции записи на диск будут
	      выполняться асинхронно.  Другими словами, запись будет
	      завершаться немедленно, но данные записываться на диск
	      несколькими секундами позже.  Это позволит объединять
	      операции записи и приведёт к значительному приросту
	      производительности.</para>

	    <para>Файловую систему с <filename>/usr/obj</filename>
	      можно смонтировать с <option>async</option> для записи
	      на диск в асинхронном режиме.  В этом случае операции
	      записи завершаются мгновенно, а сами данные записываются
	      на диск через несколько секунд.  Это позволяет писать
	      кластеризованно, что может дать значительный прирост
	      производительности.</para>

	    <warning>
	      <para>Имейте в виду, что эта опция делает вашу файловую
		систему менее устойчивой. С этой опцией имеется больше
		шансов, что при перезагрузке машины после неожиданного
		сбоя при пропадании напряжения файловая система
		окажется в невосстановимом состоянии.</para>

	      <para>Если каталог <filename>/usr/obj</filename> &mdash;
		это всё, что есть на этой файловой системе, то это не
		проблема.  Если на той же самой файловой системе
		имеются какие-то важные данные, то проверьте давность
		ваших резервных копий перед включением этой
		опции.</para>
	    </warning>

	    <para>Выключите генерацию профилирующего кода, установив
	      <quote>NO_PROFILE=true</quote> в файле
	      <filename>/etc/make.conf</filename>.</para>

	    <para>Передайте утилите &man.make.1; параметр
	      <option>-j<replaceable>n</replaceable></option>
	      для запуска параллельно нескольких процессов.  Обычно
	      это помогает вне зависимости от того, сколько
	      процессоров установлено в машине.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Что делать, если что-то пошло не так?</term>

	  <listitem>
	    <para>Скрупулезно проверьте, чтобы в вашем окружении не было
	      мешающих остатков от предыдущих построений:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Да, команду <command>make cleandir</command> действительно
	      нужно выполнять дважды.</para>

	    <para>После этого повторите весь процесс снова, начиная с
	      <command>make buildworld</command>.</para>

	    <para>Если у вас всё ещё есть проблемы, пришлите текст
	      ошибки и вывод команды <command>uname -a</command> в
	      &a.questions;.  Будьте готовы ответить на другие вопросы о
	      конфигурации вашей системы!</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info>
      <title>Отслеживание исходных текстов для нескольких машин</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	  </personname>
	  <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>

    <para>Если нужно отслеживать одно и то же дерево исходных текстов
      на множестве машин, то загрузка кода и полное перестроение
      системы на каждой из них выглядит как ненужная трата ресурсов:
      дискового пространства, пропускной способности сети и
      процессорного времени.  Решением является выделение одной машины,
      которая выполняет основной объём работы, в то время как остальные
      используют результаты работы посредством <acronym>NFS</acronym>.
      В этом разделе описывается именно этот метод.  Для получения
      информации об использовании <acronym>NFS</acronym> обращайтесь в
      <xref linkend="network-nfs"/>.</para>

    <para>Первым делом определите набор машин, на которых будет
      выполняться единый набор программ, который мы будем называть
      <firstterm>набором для построения</firstterm>.  Каждая машина
      может иметь собственное уникальное ядро, но они будут работать
      с одними и теми же программами пользователя.  Из этого набора
      выберите машину, которая будет являться <firstterm>машиной
	построения</firstterm>, на которой будут строиться ядро и
      всё окружение.  В идеальном случае это быстрая машина с
      достаточно незагруженным <acronym>CPU</acronym> для выполнения
      команд <command>make buildworld</command> и <command>make
	buildkernel</command>.</para>

    <para>Выберите <firstterm>тестовую машину</firstterm>, которая
      будет выполнять проверку обновлений программного обеспечения,
      прежде чем они пойдут в работу.  Это <emphasis>должна</emphasis>
      быть машина, которая может находиться в нерабочем состоянии
      достаточно долго.  Это также может быть машина построения, но не
      обязательно.</para>

    <para>Всем машинам в этом наборе для построения нужно смонтировать
      <filename>/usr/obj</filename> и <filename>/usr/src</filename> по
      <acronym>NFS</acronym> с машины построения.  В случае нескольких
      наборов для построения каталог <filename>/usr/src</filename>
      должен находиться на одной машине построения и монтироваться на
      остальных по <acronym>NFS</acronym>.</para>

    <para>Удостоверьтесь, что <filename>/etc/make.conf</filename> и
      <filename>/etc/src.conf</filename> на всех машинах в заданном
      наборе для построения согласуются с машиной построения.  Это
      означает, что машина построения должна строить все те части
      базовой системы, которые будут устанавливаться на каждой машине
      из набора для построения.  Кроме того, у каждой машины
      построения должно быть задано имя ядра в переменной
      <varname>KERNCONF</varname> в <filename>/etc/make.conf</filename>,
      и машина построения должна перечислить их все в переменной
      <varname>KERNCONF</varname>, причём первым должно идти имя её
      собственного ядра.  Машина построения должна хранить
      конфигурационные файлы ядра каждой машины в каталоге <filename
	>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>.</para>

    <para>Постройте ядро и всё окружение на машине построения так,
      как это описано в <xref linkend="make-buildworld"/>, но ничего
      не устанавливайте на самой машине.  Вместо этого, установите
      собранное ядро на тестовой машине.  Для этого смонтируйте
      <filename>/usr/src</filename> и <filename>/usr/obj</filename>
      по <acronym>NFS</acronym>.  Затем выполните команду
      <command>shutdown now</command> для перехода в
      однопользовательский режим, для того чтобы установить новое ядро
      и всё окружение, после чего выполните команду
      <command>mergemaster</command> обычным образом.  После этих
      действий перезагрузитесь для возврата к обычному режиму работы
      в многопользовательском режиме.</para>

    <para>После того, как вы убедитесь в нормальной работе всего на
      тестовой машине, проведите эту процедуру для установки нового
      программного обеспечения на каждой из оставшихся машин в наборе
      для построения.</para>

    <para>Такой же подход можно использовать и для дерева портов.
      Сперва нужно смонтировать <filename>/usr/ports</filename> по
      <acronym>NFS</acronym> на всех машинах в наборе для построения.
      Чтобы настроить <filename>/etc/make.conf</filename> для
      использования общего каталога с дистрибутивными файлами,
      задайте переменную <varname>DISTDIR</varname> так, чтобы она
      указывала на общедоступный каталог, доступный для записи тому
      пользователю, который отображается в пользователя <systemitem
	class="username">root</systemitem> для точек монтирования
      <acronym>NFS</acronym>.  Каждая машина должна задавать
      <varname>WRKDIRPREFIX</varname> так, чтобы она указывала на
      локальный каталог, если порты будут собираться локально.  Если
      же пакеты будут распространяться, задайте на машине построения
      переменную <varname>PACKAGES</varname>, чтобы она указывала на
      каталог, соответствующий <varname>DISTDIR</varname>.</para>
  </sect1>
</chapter>
